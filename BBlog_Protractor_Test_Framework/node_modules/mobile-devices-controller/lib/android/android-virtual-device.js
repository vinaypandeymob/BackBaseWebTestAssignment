"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const virtual_device_1 = require("../mobile-base/virtual-device");
const DeviceSignals_1 = require("../enums/DeviceSignals");
const android_controller_1 = require("../android-controller");
const utils_1 = require("../utils");
class AndroidVirtualDevice extends virtual_device_1.VirtualDevice {
    constructor() { super(); }
    startDevice(device, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.detachFromEventListeners(true);
            if (options && typeof (options) === "string") {
                const separator = options.includes(",") ? "," : " ";
                options = options.split(separator).filter(o => o);
            }
            const startedDevice = yield android_controller_1.AndroidController.startEmulator(device, { options: options });
            this._deviceProcess = startedDevice.process;
            this._device = startedDevice;
            delete this._device.process;
            this.subscribeForEvents();
            // This check is android when the emulator has s black screen and doesn't respond at all.
            this._checkEmulatorState = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                if (android_controller_1.AndroidController.getCurrentFocusedScreen(this._device).trim() === "") {
                    console.log("Device is not responding");
                    yield android_controller_1.AndroidController.reboot(this._device);
                }
            }), 30000);
            this._isAlive = true;
            this.emit(DeviceSignals_1.DeviceSignal.onDeviceStartedSignal, this._device);
            return this._device;
        });
    }
    attachToDevice(deviceInfo) {
        if (this._isAttached)
            return;
        this._isAttached = true;
        this._isAlive = true;
        this._device = deviceInfo || this._device;
        this.detachFromEventListeners(false);
        this._deviceProcess = AndroidVirtualDevice.spawnLog(this._device.token);
        super.subscribeForEvents();
        this.emit(DeviceSignals_1.DeviceSignal.onDeviceAttachedSignal, deviceInfo);
        return this._device;
    }
    detach() {
        this._isAttached = false;
        this.detachFromEventListeners(false);
    }
    stopDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._isAlive)
                return;
            yield android_controller_1.AndroidController.kill(this._device);
            this._isAlive = false;
            this._isAttached = false;
            this.detachFromEventListeners(true);
            this.emit(DeviceSignals_1.DeviceSignal.onDeviceKilledSignal, this._device);
        });
    }
    onDeviceStarted(deviceInfo) {
        utils_1.logInfo(`On device started!!!`, deviceInfo);
    }
    onDeviceError(args) {
        utils_1.logError(`An error ocurred!!!`, args);
    }
    onDeviceKilled(deviceInfo) {
        this.detachFromEventListeners(true);
        if (this._isAlive) {
            this._isAlive = false;
            utils_1.logWarn("Killed: ", deviceInfo);
            android_controller_1.AndroidController.cleanLockFiles(this._device);
        }
    }
    onDeviceAttach(deviceInfo) {
        console.log("Attached to device", deviceInfo);
    }
    detachFromEventListeners(shouldKill) {
        if (this._deviceProcess && shouldKill) {
            this._deviceProcess.removeAllListeners();
            this._deviceProcess.kill("SIGTERM");
        }
        if (this._deviceProcess) {
            this._deviceProcess.removeAllListeners();
            this._deviceProcess = null;
        }
        if (this._checkEmulatorState) {
            clearInterval(this._checkEmulatorState);
            this._checkEmulatorState = null;
        }
    }
    static spawnLog(token) {
        return child_process_1.spawn("adb", ["-s", `emulator-${token}`, 'logcat', '*:E'], {
            shell: true,
            detached: false,
            stdio: 'ignore'
        });
    }
}
exports.AndroidVirtualDevice = AndroidVirtualDevice;
//# sourceMappingURL=android-virtual-device.js.map