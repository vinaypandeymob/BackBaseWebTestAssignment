"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = require("path");
const os_1 = require("os");
const fs_1 = require("fs");
const glob_1 = require("glob");
const utils_1 = require("./utils");
const enums_1 = require("./enums");
const ios_device_lib_1 = require("ios-device-lib");
const device_controller_1 = require("./device-controller");
const util_1 = require("util");
class IOSController {
    static execXCRUNCommand(command, args, timeout = IOSController.XCRUN_COMMAND_TIMEOUT) {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                clearTimeout(timer);
                resolve({ succeeded: false });
            }, timeout);
            const proc = child_process_1.spawn(IOSController.XCRUN.trim(), [command, ...args], {
                stdio: "inherit",
            });
            let data;
            proc.on("data", (d) => {
                data += d;
                clearTimeout(timer);
            });
            proc.on('error', (err) => {
                utils_1.logError(`Command '${command}' errored out: ${err.stack}`);
                clearTimeout(timer);
                resolve({ succeeded: false });
            });
            if (proc.stdin) {
                proc.stdin.on('error', (err) => {
                    console.log(new Error(`Standard input '${err.name}' error: ${err.stack}`));
                    utils_1.logError(`Command '${command}' errored out: ${err.stack}`);
                    clearTimeout(timer);
                    resolve({ succeeded: false });
                });
            }
            if (proc.stdout) {
                proc.stdout.on('error', (err) => {
                    console.log(new Error(`Standard output '${err.name}' error: ${err.stack}`));
                    clearTimeout(timer);
                    resolve({ succeeded: false });
                });
            }
            if (proc.stderr) {
                proc.stderr.on('error', (err) => {
                    console.log(new Error(`Standard error '${err.name}' error: ${err.stack}`));
                    clearTimeout(timer);
                    resolve({ succeeded: false });
                });
            }
            proc.on("close", (close) => {
                clearTimeout(timer);
                resolve({ succeeded: true, result: data });
            });
        });
    }
    static getDl() {
        if (!IOSController._dl) {
            return new Promise((resolve, reject) => {
                const connectionTimeout = setTimeout(() => {
                    resolve(false);
                }, 30000);
                IOSController._dl = new ios_device_lib_1.IOSDeviceLib(d => {
                    console.log("Device found!", d);
                    clearTimeout(connectionTimeout);
                    resolve(IOSController._dl);
                }, device => {
                    console.log("Device LOST!");
                    resolve(false);
                });
            });
        }
        return Promise.resolve(IOSController._dl);
    }
    static disposeDL() {
        if (IOSController._dl) {
            IOSController._dl.dispose("SIGTERM");
            IOSController._dl = undefined;
        }
    }
    static getAllDevices(verbose = false) {
        if (IOSController.devicesScreenInfo.size === 0) {
            IOSController.loadIOSDevicesScreenInfo();
        }
        const devices = IOSController.parseSimulators();
        IOSController.parseRealDevices(devices);
        if (verbose) {
            console.log("All devices: ", devices);
        }
        return Promise.resolve(devices);
    }
    static getSimulatorPidByToken(token) {
        const simulatorPidAsString = utils_1.executeCommand(`ps ax | grep ${token} | grep -v grep`);
        const result = utils_1.getRegexResultsAsArray(/^\d+/gi, simulatorPidAsString);
        let pid = undefined;
        if (result.length > 0) {
            try {
                pid = parseInt(result[0].trim());
            }
            catch (error) {
                console.error("Couldn't parse simulator pid", error);
            }
        }
        return pid;
    }
    static deleteDevice(token) {
        const result = child_process_1.spawnSync(`xcrun simctl delete ${token}`, {
            shell: true
        });
        if (result.status !== 0) {
            utils_1.logError("", result.output.toString());
        }
    }
    static fullResetOfSimulator(simulator) {
        try {
            if ((!simulator.name || !simulator.createDeviceOptions || !simulator.createDeviceOptions.type) && !simulator.apiLevel) {
                console.log("To recreate simulator it is need to be specified simulator name or type and apiLevel!");
                return simulator;
            }
            const iOSDevicesInfo = child_process_1.spawnSync(IOSController.SIMCTL, ["list", "-j"], {
                shell: true,
                encoding: "UTF8"
            });
            const iOSDevicesInfoAsObj = JSON.parse(iOSDevicesInfo.stdout.toString());
            simulator.createDeviceOptions = simulator.createDeviceOptions || {};
            simulator.createDeviceOptions.type = (simulator.createDeviceOptions && simulator.createDeviceOptions.type) || simulator.name.split(" ").slice(0, 2).join("-");
            const type = iOSDevicesInfoAsObj.devicetypes.filter(dt => dt.identifier.toLowerCase().includes(simulator.createDeviceOptions.type.toLowerCase())
                || dt.name.toLowerCase().includes(simulator.createDeviceOptions.type.toLowerCase()))[0];
            if (!type) {
                utils_1.logError("Please provide correct simulator type!");
            }
            const filter = (searchQueryValue, targetValue) => {
                if (searchQueryValue) {
                    const searchPropValue = utils_1.convertStringToRegExp(searchQueryValue);
                    if (util_1.isRegExp(searchPropValue)) {
                        return searchPropValue.test(targetValue);
                    }
                    return searchQueryValue === targetValue;
                }
                else {
                    return true;
                }
            };
            const runTime = iOSDevicesInfoAsObj.runtimes.filter(drt => filter(simulator.apiLevel, drt.version)
                && new RegExp(`${simulator.platform || "ios"} ${simulator.apiLevel}`, "ig").test(drt.name))[0];
            if (!runTime) {
                utils_1.logError("No such runtime available!");
            }
            const oldToken = simulator.token;
            const command = `xcrun simctl create "${simulator.name}" "${type.name}" "${runTime.identifier}"`;
            console.log(command);
            const result = utils_1.executeCommand(command);
            if (result && result.trim()) {
                simulator.token = result.trim();
                if (oldToken) {
                    IOSController.deleteDevice(oldToken);
                    console.log(`Remove: `, oldToken);
                }
            }
            else {
                utils_1.logError("Failed to create simulator!", result);
            }
        }
        catch (error) {
            console.error(`Failed to create new simulator!`);
        }
        return simulator;
    }
    static startSimulatorInternal(simulator, directory = os_1.tmpdir(), shouldFullResetSimulator = true, retries = 3) {
        return __awaiter(this, void 0, void 0, function* () {
            simulator.type = enums_1.DeviceType.SIMULATOR;
            simulator.platform = enums_1.Platform.IOS;
            if (!simulator.token) {
                simulator = (yield device_controller_1.DeviceController.getDevices(simulator))[0];
            }
            let udid = simulator.token;
            if (utils_1.isProcessAlive("Simulator.app")
                && shouldFullResetSimulator
                && !(simulator.name
                    && simulator.name.toLowerCase().includes("iphone 7")
                    || simulator.name.toLowerCase().includes("iphone 8"))) {
                try {
                    const newSim = IOSController.fullResetOfSimulator(simulator);
                    if (newSim.token) {
                        simulator = newSim;
                        udid = simulator.token;
                    }
                }
                catch (error) { }
            }
            else if (shouldFullResetSimulator) {
                const eraseSimResult = yield IOSController.execXCRUNCommand("simctl", ["erase", udid], 120000);
                console.log("Result of erasing simulator: ", eraseSimResult);
            }
            let startedProcess = IOSController.startSimulatorProcess(udid, directory);
            // let response: boolean = await waitForOutput(process, /Instruments Trace Complete:/ig, /Failed to load/ig, IOSController.DEVICE_BOOT_TIME);
            if (startedProcess
                && (startedProcess.error
                    || (startedProcess.stderr
                        && startedProcess.stderr.toString().toLowerCase().includes("unable to boot deleted device")
                        || startedProcess.stderr.toString().toLowerCase().includes("Failed to load")))) {
                simulator.status = enums_1.Status.SHUTDOWN;
            }
            if (startedProcess && startedProcess.stdout && startedProcess.stdout.toString().includes("Instruments Trace Complete")) {
                const response = IOSController.checkIfSimulatorIsBooted(udid, IOSController.WAIT_DEVICE_TO_RESPONSE);
                if (response) {
                    simulator.type = enums_1.DeviceType.SIMULATOR;
                    simulator.status = enums_1.Status.BOOTED;
                    simulator.pid = startedProcess.pid;
                    simulator.startedAt = Date.now();
                    console.log(`Launched simulator with name: ${simulator.name}; udid: ${simulator.token}; status: ${simulator.status}`);
                }
            }
            else {
                console.log("Simulator is probably already started!");
            }
            return simulator;
        });
    }
    static startSimulator(simulator, directory = os_1.tmpdir(), shouldFullResetSimulator = true, retries = 3) {
        return __awaiter(this, void 0, void 0, function* () {
            simulator = yield IOSController.startSimulatorInternal(simulator, directory, shouldFullResetSimulator, retries);
            while (retries > 0
                &&
                    (!simulator
                        || (simulator && simulator.status !== enums_1.Status.BOOTED))) {
                retries--;
                simulator = yield IOSController.startSimulatorInternal(simulator, os_1.tmpdir(), shouldFullResetSimulator, retries);
            }
            return simulator;
        });
    }
    static restartDevice(device) {
        return __awaiter(this, void 0, void 0, function* () {
            if (device.type === enums_1.DeviceType.SIMULATOR) {
                IOSController.kill(device.token);
                device.status = enums_1.Status.SHUTDOWN;
                device.pid = undefined;
                device.startedAt = -1;
                device.busySince = -1;
                yield IOSController.startSimulator(device);
            }
        });
    }
    static killAll() {
        const log = utils_1.executeCommand("killall Simulator ");
        utils_1.executeCommand(IOSController.OSASCRIPT_QUIT_SIMULATOR_COMMAND);
    }
    static kill(udid) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!udid) {
                utils_1.logError("Please provide device token!");
            }
            console.log(`Killing simulator with udid ${udid}`);
            utils_1.executeCommand(`${IOSController.SIMCTL} shutdown ${udid}`);
            // Kill all the processes related with sim.id (for example WDA agents).
            yield utils_1.killAllProcessAndRelatedCommand(udid);
        });
    }
    static getInstalledApplications(device) {
        const apps = new Array();
        if (device.type === enums_1.DeviceType.DEVICE) {
            const rowData = utils_1.executeCommand(`ideviceinstaller -u ${device.token} -l`).replace("package:", "").split("\n");
            rowData.forEach(data => {
                const appBundle = /(\w+\.)+\w+/ig.exec(data);
                if (appBundle && appBundle.length > 0 && appBundle[0].includes(".")) {
                    apps.push(appBundle[0]);
                }
            });
        }
        else {
            const simLocation = `${IOSController.getSimLocation(device.token)}`;
            const installedApps = glob_1.glob.sync(`${simLocation}/**/*.app`);
            const rowData = installedApps
                .filter(f => {
                return f.endsWith(".app") && fs_1.statSync(f).isDirectory();
            });
            rowData.forEach(data => {
                const rowBundle = utils_1.executeCommand(`defaults read ${data}/Info.plist | grep CFBundleIdentifier`);
                const appId = rowBundle.split("\"")[1];
                apps.push(appId);
            });
        }
        return apps;
    }
    static installApplication(device, fullAppName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (device.type === enums_1.DeviceType.DEVICE) {
                const installProcess = yield (yield IOSController.getDl()).install(fullAppName, [device.token])[0];
                yield IOSController.disposeDL();
                if (!installProcess.response.includes("Successfully installed application")) {
                    console.error(installProcess.response);
                }
            }
            else {
                let result = yield IOSController.execXCRUNCommand("simctl", ["install", device.token, fullAppName]);
                if (!result.succeeded) {
                    utils_1.logInfo("Reinstalling application!");
                    result = yield IOSController.execXCRUNCommand("simctl", ["install", device.token, fullAppName]);
                    if (!result.succeeded) {
                        console.log("Probably the application is not successfully installed");
                    }
                }
            }
        });
    }
    /**
    * @param device - of type {token: string, type: DeviceType}
    * @param bundleId - should be provided when DeviceType.DEVICE else undefined
    * @param appName - should be provided when DeviceType.SIMULATOR else undefined
    **/
    static stopApplication(device, bundleId, appName) {
        return __awaiter(this, void 0, void 0, function* () {
            const apps = IOSController.getInstalledApplications(device);
            if (apps.some(app => app.includes(bundleId))) {
                if (!device.type) {
                    device.platform = enums_1.Platform.IOS;
                    const d = (yield device_controller_1.DeviceController.getDevices(device))[0];
                    device.type = d && d.type;
                }
                if (device.type && device.type === enums_1.DeviceType.SIMULATOR) {
                    //const r = await IOSController.execXCRUNCommand("simctl", ["terminate", device.token, `${bundleId}`]);
                    yield utils_1.killAllProcessAndRelatedCommand([device.token, appName]);
                }
                else {
                    const appInfo = { ddi: undefined, appId: bundleId, deviceId: device.token };
                    const dl = yield IOSController.getDl();
                    if (dl) {
                        return new Promise((res, reject) => {
                            Promise.all(dl.stop([appInfo]))
                                .then((response) => __awaiter(this, void 0, void 0, function* () {
                                console.log("App " + bundleId + " stopped !", response);
                                yield IOSController.disposeDL();
                                res(true);
                            })).catch((err) => __awaiter(this, void 0, void 0, function* () {
                                console.log("An error occurred! Probably app is still running!", err);
                                yield IOSController.disposeDL();
                                res(false);
                            }));
                        });
                    }
                }
            }
        });
    }
    static uninstallApplication(device, fullAppName, bundleId = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            bundleId = bundleId || IOSController.getBundleId(device.type, fullAppName);
            let result = "";
            try {
                yield IOSController.stopApplication(device, bundleId, !fullAppName ? fullAppName : path_1.basename(fullAppName));
                utils_1.wait(500);
            }
            catch (error) {
                console.dir(error);
            }
            if (device.type === enums_1.DeviceType.DEVICE) {
                result = utils_1.executeCommand(`ideviceinstaller -u ${device.token} -U ${bundleId}`);
            }
            else {
                result = utils_1.executeCommand(`${IOSController.SIMCTL} uninstall ${device.token} ${bundleId}`);
            }
        });
    }
    static reinstallApplication(device, fullAppName, bundleId = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            bundleId = bundleId || IOSController.getBundleId(device.type, fullAppName);
            yield IOSController.uninstallApplication(device, fullAppName, bundleId);
            yield IOSController.installApplication(device, fullAppName);
        });
    }
    static refreshApplication(device, fullAppName, bundleId = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            bundleId = bundleId || IOSController.getBundleId(device.type, fullAppName);
            yield IOSController.reinstallApplication(device, fullAppName, bundleId);
            yield IOSController.startApplication(device, fullAppName, bundleId);
        });
    }
    static startApplication(device, fullAppName, bundleId = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            bundleId = bundleId || IOSController.getBundleId(device.type, fullAppName);
            let output = "";
            let result = false;
            if (device.type === enums_1.DeviceType.DEVICE) {
                let startProcess;
                try {
                    output = yield (yield IOSController.getDl()).start([{ "ddi": undefined, "appId": bundleId, "deviceId": device.token }])[0];
                    if (!startProcess.response.includes("Successfully started application")) {
                        throw new Error(`Failed to start application ${bundleId}`);
                    }
                    else {
                        result = true;
                    }
                }
                catch (error) {
                    yield IOSController.disposeDL();
                }
                yield IOSController.disposeDL();
            }
            else {
                output = utils_1.executeCommand(`${IOSController.SIMCTL} launch ${device.token} ${bundleId}`, process.cwd(), 60000);
                result = output.includes(bundleId);
            }
            return Promise.resolve({ output: output, result: result });
        });
    }
    static startSimulatorProcess(udid, cwd = os_1.tmpdir(), timeout = IOSController.DEVICE_BOOT_TIME) {
        // xcrun instruments -v -t 'Blank' -l 100 -w
        // xcrun instruments -w ${udid} -t Blank `;
        const simProcess = child_process_1.spawnSync(IOSController.XCRUN, ['instruments', '-w', udid, '-t', 'Blank'], {
            shell: true,
            cwd: cwd,
            timeout: timeout
        });
        return simProcess;
    }
    static isRunning(token) {
        const out = utils_1.executeCommand(`${IOSController.SIMCTL} spawn ${token} launchctl print system | grep com.apple.springboard.services `);
        return out.includes("M   A   com.apple.springboard.services");
    }
    static parseSimulators(stdout = undefined) {
        const devicesAsString = utils_1.executeCommand(`${IOSController.XCRUN_LISTDEVICES_COMMAND} --json`, process.cwd(), 10000);
        if (!devicesAsString) {
            utils_1.logError(`${IOSController.XCRUN_LISTDEVICES_COMMAND} command is not responding!`);
            process.exit(1);
        }
        const devicesObj = JSON.parse(devicesAsString.toString());
        const deviceObjDevice = devicesObj["devices"];
        const devices = new Map();
        Object.getOwnPropertyNames(devicesObj["devices"])
            .forEach(level => {
            deviceObjDevice[level]
                .filter(d => d["availability"] === "(available)" || !!d["isAvailable"])
                .forEach(deviceObj => {
                const status = deviceObj.state.toLowerCase();
                const apiLevel = /\d{1,3}(\.|\-)+.+|\d+/.exec(level)[0].replace("-", ".");
                let type = enums_1.DeviceType.SIMULATOR;
                const isWatch = /watchos/gi.test(level);
                const isTv = /tvos/gi.test(level);
                if (isWatch) {
                    type = enums_1.DeviceType.WATCH;
                }
                else if (isTv) {
                    type = enums_1.DeviceType.TV;
                }
                const device = {
                    token: deviceObj.udid,
                    name: deviceObj.name,
                    status: status,
                    type: type,
                    apiLevel: apiLevel,
                    platform: enums_1.Platform.IOS
                };
                IOSController.devicesScreenInfo.forEach((v, k, m) => {
                    if (device.name.includes(k)) {
                        device.config = {
                            density: v.density,
                            offsetPixels: v.actionBarHeight
                        };
                    }
                });
                if (!devices.has(device.name)) {
                    devices.set(device.name, new Array());
                    devices.get(device.name).push(device);
                }
                else {
                    devices.get(device.name).push(device);
                }
            });
        });
        return devices;
    }
    static parseRealDevices(devices = new Map()) {
        const devicesUDID = utils_1.executeCommand("idevice_id  --list").split('\n');
        devicesUDID.forEach(udid => {
            if (udid && udid !== "") {
                const deviceInfo = utils_1.executeCommand(`ideviceinfo -s -u ${udid}`).split('\n');
                const device = {
                    type: enums_1.DeviceType.DEVICE,
                    platform: enums_1.Platform.IOS,
                    token: udid,
                    status: enums_1.Status.BOOTED,
                };
                deviceInfo.forEach(info => {
                    if (info && info.trim() !== "") {
                        if (info.toLowerCase().includes('devicename')) {
                            device.name = info.split(": ")[1].trim();
                        }
                        if (info.toLowerCase().includes('productversion')) {
                            device.apiLevel = info.split(": ")[1].trim();
                        }
                    }
                });
                if (device.name) {
                    if (devices.has(device.name)) {
                        devices.get(device.name).push(device);
                    }
                    else {
                        devices.set(device.name, [device]);
                    }
                }
            }
        });
        return devices;
    }
    static getSimLocation(token) {
        const simRootHome = path_1.resolve(process.env["HOME"], "Library/Developer/CoreSimulator/Devices/", token, "data/Containers/Bundle/Application");
        const simRoot = path_1.resolve("/Library/Developer/CoreSimulator/Devices/", token, "data/Containers/Bundle/Application");
        return fs_1.existsSync(simRootHome) ? simRootHome : simRoot;
    }
    static filterDeviceBy(...args) {
        const mappedDevices = IOSController.parseSimulators();
        const result = new Array();
        mappedDevices.forEach(devices => {
            devices.forEach(device => {
                let shouldAdd = true;
                const deviceToString = JSON.stringify(device).toLocaleLowerCase();
                args.forEach(arg => {
                    if (deviceToString.includes(arg.toLocaleLowerCase())) {
                        shouldAdd = shouldAdd && true;
                    }
                    else {
                        shouldAdd = false;
                    }
                });
                if (shouldAdd) {
                    result.push(device);
                }
            });
        });
        return result;
    }
    static getScreenshot(device, dir, fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const pathToScreenshotPng = path_1.resolve(dir, `${fileName}.png`);
            if (device.type === enums_1.DeviceType.DEVICE) {
                utils_1.executeCommand(`idevicescreenshot -u ${device.token} ${pathToScreenshotPng}`);
            }
            else {
                utils_1.executeCommand(`${IOSController.SIMCTL} io ${device.token} screenshot ${pathToScreenshotPng}`);
            }
            return pathToScreenshotPng;
        });
    }
    static recordVideo(device, dir, fileName, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pathToVideo, videoRecordingProcess } = IOSController.startRecordingVideo(device, dir, fileName);
            return new Promise((res, reject) => __awaiter(this, void 0, void 0, function* () {
                callback().then((result) => {
                    videoRecordingProcess.kill("SIGINT");
                    console.log(result);
                    res(pathToVideo);
                }).catch((error) => {
                    if (videoRecordingProcess) {
                        videoRecordingProcess.kill("SIGINT");
                    }
                    console.log('', error);
                    reject(error);
                });
            }));
        });
    }
    static startRecordingVideo(device, dir, fileName) {
        let pathToVideo = path_1.resolve(dir, `${fileName}.mp4`).replace(" ", "\ ");
        if (fs_1.existsSync(pathToVideo)) {
            fs_1.unlinkSync(pathToVideo);
        }
        let videoRecordingProcess;
        if (device.type === enums_1.DeviceType.DEVICE) {
            const p = path_1.resolve(__dirname, "../", "bin", "xrecord");
            console.log(`${p} --quicktime --id=${device.token} --out=${pathToVideo} --force`);
            const startRecording = () => {
                return child_process_1.spawn(`${p}`, [`--quicktime`, `--id=\"${device.token}\"`, `--out=\"${pathToVideo}\"`, `--force`], {
                    stdio: 'inherit',
                    shell: true
                });
            };
            videoRecordingProcess = startRecording();
            utils_1.wait(3000);
            const checkHasStartedRecording = (timeout, pathToVideo) => {
                const startTime = Date.now();
                while (Date.now() - startTime <= timeout && !fs_1.existsSync(pathToVideo)) {
                }
                return fs_1.existsSync(pathToVideo);
            };
            let retryCount = 10;
            let awaitOnRecordingStart = false;
            while (!checkHasStartedRecording(5000, pathToVideo) && retryCount >= 0) {
                try {
                    child_process_1.execSync("killall 'QuickTime Player'");
                }
                catch (error) { }
                try {
                    videoRecordingProcess.kill("SIGTERM");
                }
                catch (error) { }
                retryCount--;
                utils_1.wait(2000);
                const quicktimeAppleScriptPath = path_1.resolve(__dirname, "../bin/startQuickTimePlayer.scpt");
                child_process_1.spawnSync('osascript', [quicktimeAppleScriptPath, '10'], {
                    shell: true,
                    stdio: 'inherit'
                });
                videoRecordingProcess = startRecording();
                awaitOnRecordingStart = true;
            }
            if (awaitOnRecordingStart)
                utils_1.wait(3000);
            if (!fs_1.existsSync(pathToVideo)) {
                console.error(`Couldn't start recording process!`);
                console.error(`Recording couldn't be started! Check device connection and quick time player`);
                videoRecordingProcess = null;
                pathToVideo = null;
            }
        }
        else {
            console.log(`${IOSController.XCRUN} simctl io ${device.token} recordVideo ${pathToVideo}`);
            videoRecordingProcess = child_process_1.spawn(`xcrun`, ['simctl ', 'io', device.token, 'recordVideo', `'${pathToVideo}'`], {
                cwd: process.cwd(),
                shell: true,
                stdio: 'inherit'
            });
        }
        if (videoRecordingProcess) {
            IOSController.runningProcesses.push(videoRecordingProcess.pid);
        }
        return { pathToVideo: pathToVideo, videoRecordingProcess: videoRecordingProcess };
    }
    // Should find a better way
    static checkIfSimulatorIsBooted(udid, timeout) {
        const startTime = new Date().getTime();
        let currentTime = new Date().getTime();
        console.log("Check if simulator is booted!");
        let booted = false;
        while ((currentTime - startTime) < timeout && !booted) {
            currentTime = new Date().getTime();
            const devices = IOSController.filterDeviceBy(udid, enums_1.Status.BOOTED);
            booted = devices.length > 0 && IOSController.isRunning(udid);
        }
        if (!booted) {
            let error = `Simulator with " ${udid} failed to boot`;
            console.log(error, true);
        }
        else {
            console.log("Simulator is booted!");
        }
        return booted;
    }
    static getBundleId(deviceType, fullAppName) {
        let result = "";
        const plistPath = IOSController.getPlistPath(fullAppName);
        if (fs_1.existsSync(plistPath)) {
            const command = "/usr/libexec/PlistBuddy -c 'Print CFBundleIdentifier' " + plistPath;
            result = utils_1.executeCommand(command);
        }
        else {
            console.error("File " + plistPath + " does not exist.");
        }
        return result.trim();
    }
    static getDevicesScreenInfo() {
        if (IOSController.devicesScreenInfo.size == 0) {
            IOSController.loadIOSDevicesScreenInfo();
        }
        return IOSController.devicesScreenInfo;
    }
    /**
     * Get path of Info.plist of iOS app under test.
     * Info.plist holds information for app under test.
     *
     * @return path to Info.plist
     */
    static getPlistPath(fullAppName) {
        let plistPath = null;
        const ext = path_1.extname(fullAppName);
        if (ext.includes('ipa')) {
            const appFullName = path_1.dirname(fullAppName) + path_1.sep + path_1.basename(fullAppName).replace(".ipa", "");
            const command = `unzip -o ${fullAppName} -d ${appFullName}`;
            console.log(command);
            utils_1.executeCommand(command);
            const appName = utils_1.executeCommand(`ls ${path_1.resolve(appFullName, "Payload")}`).split('\n').filter(f => f.includes(".app"))[0];
            plistPath = path_1.resolve(appFullName, "Payload", appName, "Info.plist");
        }
        else {
            plistPath = path_1.resolve(fullAppName, "Info.plist");
        }
        return plistPath;
    }
    // Not testes to the end
    static waitForBootInSystemLog(simulator, bootedIndicator, startupTimeout) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield IOSController.tailLogsUntil(simulator.token, bootedIndicator, startupTimeout);
        });
    }
    static tailLogsUntil(token, bootedIndicator, timeoutMs) {
        return __awaiter(this, void 0, void 0, function* () {
            let simLog = path_1.resolve(IOSController.getLogDir(token), 'system.log');
            // we need to make sure log file exists before we can tail it
            let exists = fs_1.existsSync(simLog);
            while (!exists) {
                exists = fs_1.existsSync(simLog);
            }
            console.info(`Simulator log at '${simLog}'`);
            console.info(`Tailing simulator logs until we encounter the string "${bootedIndicator}"`);
            console.info(`We will time out after ${timeoutMs}ms`);
            let isBooted = false;
            try {
                let result = utils_1.tailFileUntil(simLog, "com.apple.intents.intents-image-service", 0);
                while (!result.result) {
                    result = utils_1.tailFileUntil(simLog, bootedIndicator, result.index);
                }
                isBooted = result.result;
            }
            catch (err) {
                console.debug('Simulator startup timed out. Continuing anyway.');
            }
            return isBooted;
        });
    }
    static getLogDir(token) {
        let home = process.env.HOME;
        return path_1.resolve(home, 'Library', 'Logs', 'CoreSimulator', token);
    }
    static loadIOSDevicesScreenInfo() {
        IOSController.devicesDisplaysInfos().forEach(d => {
            IOSController.devicesScreenInfo.set(d.deviceType, d);
        });
    }
    static devicesDisplaysInfos() {
        const devicesInfo = new Array({
            deviceType: "iPhone 6",
            width: 750,
            height: 1334,
            density: 2,
            actionBarHeight: 40
        }, {
            deviceType: "iPhone 6s",
            width: 750,
            height: 1334,
            density: 2,
            actionBarHeight: 40
        }, {
            deviceType: "iPhone 6 Plus",
            width: 1242,
            height: 2208,
            density: 3,
            actionBarHeight: 60
        }, {
            deviceType: "iPhone 7 Plus",
            width: 1242,
            height: 2208,
            density: 3,
            actionBarHeight: 60
        }, {
            deviceType: "iPhone 7",
            width: 750,
            height: 1334,
            density: 2,
            actionBarHeight: 40
        }, {
            deviceType: "iPhone 8",
            height: 1334,
            width: 750,
            density: 2,
            actionBarHeight: 40
        }, {
            deviceType: "iPhone 8 Plus",
            width: 1242,
            height: 2208,
            density: 3,
            actionBarHeight: 60
        }, {
            deviceType: "iPhone X",
            width: 1242,
            height: 2208,
            density: 3,
            actionBarHeight: 132
        }, {
            deviceType: "iPhone XR",
            width: 828,
            height: 1792,
            density: 2,
            actionBarHeight: 88
        }, {
            deviceType: "iPhone XS",
            width: 1125,
            height: 2436,
            density: 3,
            actionBarHeight: 132
        }, {
            deviceType: "iPhone XS Max",
            width: 1242,
            height: 2688,
            density: 3,
            actionBarHeight: 132
        }, {
            deviceType: "iPhone 11",
            width: 828,
            height: 1792,
            density: 2,
            actionBarHeight: 88
        }, {
            deviceType: "iPhone 11 Pro",
            width: 375,
            height: 812,
            density: 3,
            actionBarHeight: 132
        });
        // longest names at the start
        const sortedDevices = devicesInfo.sort((a, b) => {
            return b.deviceType.length - a.deviceType.length;
        });
        return sortedDevices;
    }
}
exports.IOSController = IOSController;
IOSController.XCRUN = "/usr/bin/xcrun ";
IOSController.SIMCTL = `${IOSController.XCRUN} simctl`;
IOSController.XCRUN_LISTDEVICES_COMMAND = `${IOSController.SIMCTL} list devices `;
IOSController.OSASCRIPT_QUIT_SIMULATOR_COMMAND = "osascript -e 'tell application \"Simulator\" to quit'";
IOSController.IOS_DEVICE = "ios-device";
IOSController.devicesScreenInfo = new Map();
IOSController.DEVICE_BOOT_TIME = 180000;
IOSController.WAIT_DEVICE_TO_RESPONSE = 180000;
IOSController.XCRUN_COMMAND_TIMEOUT = 180000;
IOSController.runningProcesses = new Array();
//# sourceMappingURL=ios-controller.js.map