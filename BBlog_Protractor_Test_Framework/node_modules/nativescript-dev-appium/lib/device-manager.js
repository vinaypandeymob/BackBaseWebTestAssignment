"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const mobile_devices_controller_1 = require("mobile-devices-controller");
const util_1 = require("util");
class DeviceManager {
    constructor() {
    }
    startDevice(args) {
        return __awaiter(this, void 0, void 0, function* () {
            args.appiumCaps.platformName = args.appiumCaps.platformName.toLowerCase();
            const shouldFullyResetDevice = !args.appiumCaps.udid;
            let device = DeviceManager.getDefaultDevice(args);
            const token = process.env["DEVICE_TOKEN"] || process.env.npm_config_deviceToken;
            device.token = token && token.replace("emulator-", "");
            device.name = process.env["DEVICE_NAME"] || device.name;
            DeviceManager.cleanUnsetProperties(device);
            if (args.ignoreDeviceController) {
                console.log("Default device: ", device);
            }
            if (utils_1.shouldUserMobileDevicesController(args)) {
                device = (yield mobile_devices_controller_1.DeviceController.getDevices(device))[0];
                utils_1.logInfo("Device: ", device);
                return device;
            }
            // When '--isSauceLab' option is set we should do nothing;
            if (args.isSauceLab || args.ignoreDeviceController) {
                args.ignoreDeviceController = true;
                DeviceManager._emulators.set(args.runType, device);
                return device;
            }
            const searchQuery = args.appiumCaps.udid ? { token: args.appiumCaps.udid } : Object.assign(device);
            const foundDevices = (yield mobile_devices_controller_1.DeviceController.getDevices(searchQuery))
                .sort((a, b) => mobile_devices_controller_1.sortDescByApiLevelPredicate(a, b));
            if (!foundDevices || foundDevices.length === 0) {
                utils_1.logError("We couldn't find any devices of type: ", searchQuery);
                utils_1.logError("We will try to proceed to appium!");
                if (device.platform) {
                    console.log("Available devices:\t\t\t\t", yield mobile_devices_controller_1.DeviceController.getDevices({ platform: device.platform }));
                }
                else {
                    console.log("Available devices:\t\t\t\t", yield mobile_devices_controller_1.DeviceController.getDevices({}));
                }
                utils_1.logWarn(`We couldn't find any devices. We will try to proceed to appium!`);
                if (args.appiumCaps.platformVersion.toLowerCase() === mobile_devices_controller_1.Platform.ANDROID) {
                    const errMsg = `1. Check if ANDROID_HOME environment variable is set correctly!\n
                2. Check if avd manager is available!
                3. Check appium capabilities and provide correct device options!`;
                    utils_1.logWarn(errMsg);
                }
                args.ignoreDeviceController = true;
                return device;
            }
            if (args.verbose) {
                console.log("Found devices: ", foundDevices);
            }
            if (foundDevices && foundDevices.length > 0) {
                let deviceStatus = args.reuseDevice ? mobile_devices_controller_1.Status.BOOTED : mobile_devices_controller_1.Status.SHUTDOWN;
                device = mobile_devices_controller_1.DeviceController.filter(foundDevices, { status: deviceStatus })
                    .filter(d => d.type !== mobile_devices_controller_1.DeviceType.TV && d.type !== mobile_devices_controller_1.DeviceType.WATCH)[0];
                // If there is no shutdown device
                if (!device || !device.status) {
                    deviceStatus = args.reuseDevice ? mobile_devices_controller_1.Status.SHUTDOWN : mobile_devices_controller_1.Status.BOOTED;
                    device = mobile_devices_controller_1.DeviceController.filter(foundDevices, { status: deviceStatus })
                        .filter(d => d.type !== mobile_devices_controller_1.DeviceType.TV && d.type !== mobile_devices_controller_1.DeviceType.WATCH)[0];
                }
                // If the device should not be reused we need to shutdown device and boot a clean instance
                let startDeviceOptions = args.startDeviceOptions || undefined;
                if (!args.reuseDevice && device.status !== mobile_devices_controller_1.Status.SHUTDOWN) {
                    yield mobile_devices_controller_1.DeviceController.kill(device);
                    device.status = mobile_devices_controller_1.Status.SHUTDOWN;
                    startDeviceOptions = device.type === mobile_devices_controller_1.DeviceType.EMULATOR ? "-wipe-data -no-snapshot-load -no-boot-anim -no-audio -snapshot clean_boot" : "";
                    utils_1.logInfo("Change appium config to fullReset: false if no restart of the device needed!");
                }
                if (device.type === mobile_devices_controller_1.DeviceType.DEVICE) {
                    utils_1.logInfo("Device is connected:", device);
                }
                if (device.status === mobile_devices_controller_1.Status.SHUTDOWN) {
                    device = yield mobile_devices_controller_1.DeviceController.startDevice(device, startDeviceOptions, shouldFullyResetDevice);
                    try {
                        delete device.process;
                    }
                    catch (error) { }
                    utils_1.logInfo("Started device: ", device);
                }
            }
            if (device.platform === mobile_devices_controller_1.Platform.ANDROID) {
                mobile_devices_controller_1.AndroidController.clearLog(device);
            }
            DeviceManager._emulators.set(args.runType, device);
            if (!device || !device.token) {
                console.error("Check appium capabilities and provide correct device options!");
                process.exit(1);
            }
            if (!args.ignoreDeviceController) {
                console.log("Default device: ", device);
            }
            return device;
        });
    }
    stopDevice(device, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args.reuseDevice
                && !args.isSauceLab
                && !args.ignoreDeviceController) {
                yield DeviceManager.kill(device);
            }
        });
    }
    static getDevices(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield mobile_devices_controller_1.DeviceController.getDevices(query);
        });
    }
    installApp(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.isIOS) {
                mobile_devices_controller_1.IOSController.uninstallApplication(args.device, args.appiumCaps.app);
                console.log(`Application is successfully installed!`);
            }
            else {
                mobile_devices_controller_1.AndroidController.uninstallApplication(args.device, args.appiumCaps.app);
            }
        });
    }
    uninstallApp(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.isIOS) {
                yield mobile_devices_controller_1.IOSController.uninstallApplication(args.device, args.appPath, args.appiumCaps["bundleId"]);
            }
            else {
                yield Promise.resolve(mobile_devices_controller_1.AndroidController.uninstallApplication(args.device, args.appiumCaps["appPackage"]));
            }
        });
    }
    static kill(device) {
        return __awaiter(this, void 0, void 0, function* () {
            if (device) {
                yield mobile_devices_controller_1.DeviceController.kill(device);
            }
        });
    }
    static getInstalledApps(device) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield mobile_devices_controller_1.DeviceController.getInstalledApplication(device);
        });
    }
    static getDefaultDevice(args, deviceName, token, type, platformVersion) {
        let device = {
            name: deviceName || args.appiumCaps.deviceName,
            type: type,
            platform: args.appiumCaps.platformName.toLowerCase(),
            token: token,
            apiLevel: platformVersion || args.appiumCaps.platformVersion,
            config: { "density": args.appiumCaps.density, "offsetPixels": args.appiumCaps.offsetPixels }
        };
        DeviceManager.cleanUnsetProperties(device);
        return device;
    }
    static convertViewportRectToIRectangle(viewportRect) {
        if (!viewportRect) {
            return viewportRect;
        }
        return {
            x: viewportRect.left,
            y: viewportRect.top,
            width: viewportRect.width,
            height: viewportRect.height,
        };
    }
    static applyAppiumSessionInfoDetails(args, sessionInfoDetails) {
        if (args.isAndroid) {
            const sizeArr = sessionInfoDetails.deviceScreenSize.split("x");
            args.device.deviceScreenSize = { width: sizeArr[0], height: sizeArr[1] };
            args.device.apiLevel = sessionInfoDetails.deviceApiLevel;
            args.device.deviceScreenDensity = sessionInfoDetails.deviceScreenDensity / 100;
            args.device.config = { "density": args.device.deviceScreenDensity || args.device.config.density, "offsetPixels": +sessionInfoDetails.statBarHeight || args.device.config.offsetPixels };
        }
        else {
            args.device.apiLevel = sessionInfoDetails.platformVersion;
            args.device.deviceScreenDensity = sessionInfoDetails.pixelRatio || args.device.config.density;
            const offsetPixels = +sessionInfoDetails.viewportRect.top - +sessionInfoDetails.statBarHeight;
            args.device.config = { "density": sessionInfoDetails.pixelRatio || args.device.config.density, "offsetPixels": util_1.isNumber(offsetPixels) ? offsetPixels : args.device.config.offsetPixels };
        }
        args.device.statBarHeight = sessionInfoDetails.statBarHeight;
        args.device.viewportRect = DeviceManager.convertViewportRectToIRectangle(sessionInfoDetails.viewportRect);
        return args.device;
    }
    static setDontKeepActivities(args, driver, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const status = value ? 1 : 0;
            try {
                if (args.isAndroid) {
                    if (!args.ignoreDeviceController) {
                        mobile_devices_controller_1.AndroidController.setDontKeepActivities(value, args.device);
                    }
                    else if (args.relaxedSecurity) {
                        const output = yield DeviceManager.executeShellCommand(driver, { command: "settings", args: ['put', 'global', 'always_finish_activities', status] });
                        console.log(`Output from setting always_finish_activities to ${status}: ${output}`);
                        //check if set 
                        const check = yield DeviceManager.executeShellCommand(driver, { command: "settings", args: ['get', 'global', 'always_finish_activities'] });
                        console.info(`Check if always_finish_activities is set correctly: ${check}`);
                    }
                }
                else {
                    // Do nothing for iOS ...
                }
            }
            catch (error) {
                utils_1.logError(`Could not set don't keep activities: ${status}!`);
                utils_1.logError(error);
            }
        });
    }
    static executeShellCommand(driver, commandArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield driver.execute("mobile: shell", commandArgs);
            return output;
        });
    }
    /**
     * Android only
     * @param args
     * @param driver
     */
    static setDensity(args, driver) {
        return __awaiter(this, void 0, void 0, function* () {
            args.device.config = args.device.config || {};
            if (args.appiumCaps.platformName.toLowerCase() === "android") {
                if (!args.ignoreDeviceController) {
                    args.device.config.density = yield mobile_devices_controller_1.AndroidController.getPhysicalDensity(args.device);
                }
                if (args.relaxedSecurity && !args.device.config.density) {
                    const d = yield DeviceManager.executeShellCommand(driver, { command: "wm", args: ["density"] });
                    args.device.config.density = /\d+/ig.test(d) ? parseInt(/\d+/ig.exec(d)[0]) / 100 : NaN;
                    console.log(`Device density received from adb shell command ${args.device.config.density}`);
                }
                if (args.device.config.density) {
                    args.device.config['offsetPixels'] = mobile_devices_controller_1.AndroidController.calculateScreenOffset(args.device.config.density);
                }
            }
        });
    }
    // public static async applyDeviceAdditionsSettings(args: INsCapabilities, appiumCaps: any) {
    //     if (appiumCaps) {
    //         args.device.config.offsetPixels = appiumCaps.offsetPixels || args.device.config.offsetPixels;
    //         args.device.config.density = appiumCaps.density || args.device.config.density;
    //     }
    // }
    static applyDeviceAdditionsSettings(driver, args, sessionInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((!args.device.viewportRect || !args.device.viewportRect.x) && (!args.device.config || !util_1.isNumber(args.device.config.offsetPixels))) {
                args.device.config = {};
                let density;
                if (sessionInfo && Object.getOwnPropertyNames(sessionInfo).length >= 1) {
                    density = sessionInfo.pixelRatio ? sessionInfo.pixelRatio : undefined;
                }
                if (density) {
                    console.log(`Get density from appium session: ${density}`);
                    args.device.config['density'] = density;
                    args.device.config['offsetPixels'] = mobile_devices_controller_1.AndroidController.calculateScreenOffset(args.device.config.density);
                }
                if (!density && !args.isIOS) {
                    yield DeviceManager.setDensity(args, driver);
                    density = args.device.config.density;
                    args.device.config['offsetPixels'] = mobile_devices_controller_1.AndroidController.calculateScreenOffset(args.device.config.density);
                }
                density ? utils_1.logInfo(`Device setting:`, args.device.config) : console.log(`Could not resolve device density. Please provide offset in appium config`);
            }
        });
    }
    getPackageId(device, appPath) {
        const appActivity = (device.type === mobile_devices_controller_1.DeviceType.EMULATOR || device.platform === mobile_devices_controller_1.Platform.ANDROID) ? mobile_devices_controller_1.AndroidController.getPackageId(appPath) : mobile_devices_controller_1.IOSController.getBundleId(device.type, appPath);
        return appActivity;
    }
    static cleanUnsetProperties(obj) {
        Object.getOwnPropertyNames(obj).forEach(prop => !obj[prop] && delete obj[prop]);
    }
}
DeviceManager._emulators = new Map();
exports.DeviceManager = DeviceManager;
//# sourceMappingURL=device-manager.js.map