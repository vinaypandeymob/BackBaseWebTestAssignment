"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const utils_1 = require("./utils");
const device_manager_1 = require("./device-manager");
const fs_1 = require("fs");
const mobile_devices_controller_1 = require("mobile-devices-controller");
const screenshot_manager_1 = require("./helpers/screenshot-manager");
const log_image_type_1 = require("./enums/log-image-type");
class AppiumServer {
    constructor(_args) {
        this._args = _args;
        this._runType = this._args.runType;
        this._hasStarted = false;
        this._port = _args.port;
        this.resolveAppiumDependency();
    }
    get port() {
        return this._port;
    }
    set port(port) {
        this._port = port;
    }
    set runType(runType) {
        this._runType = runType;
    }
    get runType() {
        return this._runType;
    }
    get server() {
        return this._server;
    }
    get hasStarted() {
        return this._hasStarted;
    }
    set hasStarted(hasStarted) {
        this._hasStarted = hasStarted;
    }
    start(port, deviceManager = new device_manager_1.DeviceManager()) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._args.isValidated && this._args.validateArgs) {
                yield this._args.validateArgs();
                this._args.port = port;
            }
            this._args.deviceManager = deviceManager;
            if (this._args.isValidated && !this._args.attachToDebug && !this._args.sessionId) {
                yield this.prepDevice(deviceManager);
                yield this.prepApp();
            }
            if (this._args.isSauceLab) {
                utils_1.logInfo(`SauceLab option is set to true. Skip starting of appium server!`);
                return this;
            }
            utils_1.log("Starting server...", this._args.verbose);
            const logLevel = this._args.verbose === true ? "debug" : "info";
            this.port = this._args.port || port;
            if (!this._args.attachToDebug) {
                this.startAppiumServer(logLevel, this._args.isSauceLab);
                let response = yield utils_1.waitForOutput(this._server, /listener started/, /Error: listen/, 60000, this._args.verbose);
                let retries = 11;
                while (retries > 0 && !response) {
                    if (retries < 5) {
                        mobile_devices_controller_1.killAllProcessAndRelatedCommand(this._port);
                    }
                    retries--;
                    this.port += 10;
                    this.port = (yield utils_1.findFreePort(100, this.port));
                    this.startAppiumServer(logLevel, this._args.isSauceLab);
                    response = yield utils_1.waitForOutput(this._server, /listener started/, /Error: listen/, 60000, true);
                }
                this.hasStarted = response;
                try {
                    utils_1.ensureReportsDirExists(this._args);
                    if (utils_1.checkImageLogType(this._args.testReporter, log_image_type_1.LogImageType.screenshots)) {
                        this._args.testReporterLog(`on_server_started`);
                        this._args.testReporterLog(screenshot_manager_1.screencapture(`${utils_1.getReportPath(this._args)}/on_server_started.png`));
                    }
                }
                catch (error) {
                    utils_1.logError(`Appium server is NOT started - ${error.message}`);
                    if (utils_1.checkImageLogType(this._args.testReporter, log_image_type_1.LogImageType.screenshots)) {
                        this._args.testReporterLog(`on_start_server_failure`);
                        this._args.testReporterLog(screenshot_manager_1.screencapture(`${utils_1.getReportPath(this._args)}/on_start_server_failure.png`));
                    }
                }
                return response;
            }
            else if (!this._args.attachToDebug) {
                return true;
            }
            return false;
        });
    }
    startAppiumServer(logLevel, isSauceLab) {
        const startingServerArgs = isSauceLab ? ["--log-level", logLevel] : ["-p", this.port.toString(), "--log-level", logLevel];
        if (this._args.isAndroid && this._args.ignoreDeviceController && !this._args.isSauceLab) {
            this._args.relaxedSecurity ? startingServerArgs.push("--relaxed-security") : console.log("'relaxedSecurity' is not enabled!\nTo enabled it use '--relaxedSecurity'!");
        }
        utils_1.logInfo(`Server args: `, startingServerArgs);
        this._server = child_process_1.spawn(this._appium, startingServerArgs);
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            const onServerKilled = (server, signal, code, verbose) => {
                utils_1.log(`Appium terminated due signal: ${signal} and code: ${code}`, verbose);
                server && server.removeAllListeners();
            };
            yield this._args.deviceManager.stopDevice(this._args.device, this._args);
            return new Promise((resolve, reject) => {
                this._server.once("close", (code, signal) => {
                    onServerKilled(this._server, signal, code, this._args.verbose);
                    resolve();
                });
                this._server.once("exit", (code, signal) => {
                    onServerKilled(this._server, signal, code, this._args.verbose);
                    resolve();
                });
                this._server.once("error", (code, signal) => {
                    onServerKilled(this._server, signal, code, this._args.verbose);
                    resolve();
                });
                this._server.once("disconnect", (code, signal) => {
                    onServerKilled(this._server, signal, code, this._args.verbose);
                    resolve();
                });
                utils_1.log("Stopping server...", this._args.verbose);
                try {
                    if (utils_1.isWin()) {
                        utils_1.shutdown(this._server, this._args.verbose);
                        this._server.kill("SIGINT");
                        this._server.kill("SIGINT");
                        this._server = null;
                    }
                    else {
                        this._server.kill("SIGINT");
                        this._server.kill("SIGINT");
                        this._server.kill("SIGKILL");
                        process.kill(this._server.pid, "SIGKILL");
                        utils_1.shutdown(this._server, this._args.verbose);
                        try {
                            if (utils_1.checkImageLogType(this._args.testReporter, log_image_type_1.LogImageType.screenshots)) {
                                this._args.testReporterLog(`on_server_stopped`);
                                this._args.testReporterLog(screenshot_manager_1.screencapture(`${utils_1.getReportPath(this._args)}/on_server_stopped.png`));
                            }
                        }
                        catch (error) { }
                    }
                }
                catch (error) {
                    console.log(error);
                }
            });
        });
    }
    prepDevice(deviceManager) {
        return __awaiter(this, void 0, void 0, function* () {
            this._args = yield utils_1.prepareDevice(this._args, deviceManager);
        });
    }
    prepApp() {
        return __awaiter(this, void 0, void 0, function* () {
            this._args = yield utils_1.prepareApp(this._args);
        });
    }
    // Resolve appium dependency
    resolveAppiumDependency() {
        const projectDir = this._args.projectDir;
        const pluginBinary = this._args.pluginBinary;
        const projectBinary = this._args.projectBinary;
        const pluginRoot = this._args.pluginRoot;
        let appium = process.platform === "win32" ? "appium.cmd" : "appium";
        if (!this._args.attachToDebug && !this._args.sessionId) {
            this._appium = appium;
            return;
        }
        const pluginAppiumBinary = utils_1.resolvePath(pluginBinary, appium);
        const projectAppiumBinary = utils_1.resolvePath(projectBinary, appium);
        if (fs_1.existsSync(pluginAppiumBinary)) {
            utils_1.logInfo("Using plugin-local Appium binary.", this._args.verbose);
            appium = pluginAppiumBinary;
        }
        else if (fs_1.existsSync(projectAppiumBinary)) {
            utils_1.logInfo("Using project-local Appium binary.", this._args.verbose);
            appium = projectAppiumBinary;
        }
        else {
            // TODO: find faster and reliable way to check if appium is installed globally
            //const result = executeCommand("npm list -g");
            // if (result.includes("appium")) {
            utils_1.logWarn("Using global Appium binary.");
            //    console.log('Please, make sure it is installed globally.');
            //} else if (result.includes("appium")) {
            //    const msg = "Appium not found. Please install appium before running tests!";
            //    log(msg, this._args.verbose);
            //    new Error(msg);
            // }
        }
        this._appium = appium;
    }
}
exports.AppiumServer = AppiumServer;
//# sourceMappingURL=appium-server.js.map