"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const wd = require("wd");
const webdriverio = require("webdriverio");
const element_helper_1 = require("./element-helper");
const search_options_1 = require("./search-options");
const ui_element_1 = require("./ui-element");
const locators_1 = require("./locators");
const mobile_devices_controller_1 = require("mobile-devices-controller");
const utils_1 = require("./utils");
const image_helper_1 = require("./image-helper");
const fs_1 = require("fs");
const device_manager_1 = require("../lib/device-manager");
const path_1 = require("path");
const log_types_1 = require("./log-types");
const screenshot_manager_1 = require("./helpers/screenshot-manager");
const log_image_type_1 = require("./enums/log-image-type");
const device_orientation_1 = require("./enums/device-orientation");
const automation_name_1 = require("./automation-name");
class AppiumDriver {
    constructor(_driver, _wd, _webio, _driverConfig, _args) {
        this._driver = _driver;
        this._wd = _wd;
        this._webio = _webio;
        this._driverConfig = _driverConfig;
        this._args = _args;
        this._defaultWaitTime = 5000;
        this._isAlive = false;
        this._elementHelper = new element_helper_1.ElementHelper(this._args);
        this._imageHelper = new image_helper_1.ImageHelper(this._args, this);
        this._isAlive = true;
        this._locators = new locators_1.Locator(this._args);
        this._webio.requestHandler.sessionID = this._driver.sessionID;
    }
    get imageHelper() {
        return this._imageHelper;
    }
    get defaultWaitTime() {
        return this._defaultWaitTime;
    }
    set defaultWaitTime(waitTime) {
        this._defaultWaitTime = waitTime;
    }
    get capabilities() {
        return this._args.appiumCaps;
    }
    get nsCapabilities() {
        return this._args;
    }
    get platformName() {
        return this._args.appiumCaps.platformName;
    }
    get platformVersion() {
        return this._args.appiumCaps.platformVersion;
    }
    get elementHelper() {
        return this._elementHelper;
    }
    get locators() {
        return this._locators;
    }
    get isAlive() {
        return this._isAlive;
    }
    get isAndroid() {
        return this._args.isAndroid;
    }
    get isIOS() {
        return this._args.isIOS;
    }
    get driver() {
        return this._driver;
    }
    /**
    * Get the storage where test results from image comparison is logged. The path should be reports/app nam/device name
    */
    get reportsPath() {
        return this._args.reportsPath;
    }
    /**
    * Get the storage where images are captured by platform. It will be resources/app nam/platform name
    */
    get storageByPlatform() {
        return this._storageByPlatform;
    }
    /**
     * Get the storage where images are captured. It will be resources/app nam/device name
     */
    get storageByDeviceName() {
        return this._args.storageByDeviceName;
    }
    set storageByDeviceName(storageFullPath) {
        this._args.storageByDeviceName = storageFullPath;
    }
    get storage() {
        return utils_1.getStorage(this._args);
    }
    /**
     * Returns instance of wd.TouchAction object
     */
    get touchAction() {
        return new this._wd.TouchAction(this._driver);
    }
    webio() {
        return this._webio;
    }
    wd() {
        return this._wd;
    }
    click(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._webio.click(args);
        });
    }
    navBack() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._driver.back();
        });
    }
    // Still not supported in wd
    // public async getPerformanceDataTypes() {
    //     return await this._driver.getSupportedPerformanceDataTypes;
    // }
    // public async getPerformanceData(type, timeout: number = 5) {
    //     return await this._driver.getPerformanceData(this._args.appiumCaps.appPackage, type, timeout);
    // }
    static createAppiumDriver(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let appiumCapsFromConfig;
            args.appiumCaps;
            if (args.appiumCaps && args.appiumCaps.settings) {
                appiumCapsFromConfig = {};
                Object.getOwnPropertyNames(args.appiumCaps).forEach(prop => {
                    appiumCapsFromConfig[prop] = args.appiumCaps[prop];
                });
                delete args.appiumCaps.settings;
            }
            if (!args.isValidated) {
                yield args.validateArgs();
            }
            utils_1.log("Creating driver!", args.verbose);
            if (!args.attachToDebug && !args.sessionId) {
                if (!args.device) {
                    args.deviceManager = args.deviceManager || new device_manager_1.DeviceManager();
                    yield utils_1.prepareDevice(args, args.deviceManager);
                    yield utils_1.prepareApp(args);
                }
                yield AppiumDriver.applyAdditionalSettings(args);
            }
            const webio = webdriverio.remote({
                baseUrl: args.driverConfig.host,
                port: args.driverConfig.port,
                desiredCapabilities: args.appiumCaps
            });
            const driver = yield wd.promiseChainRemote(args.driverConfig);
            AppiumDriver.configureLogging(driver, args.verbose);
            let hasStarted = false;
            let retries = 10;
            let sessionInfoDetails;
            while (retries > 0 && !hasStarted) {
                try {
                    let sessionInfo;
                    try {
                        if (args.sessionId || args.attachToDebug) {
                            const sessionInfos = JSON.parse(((yield utils_1.getSessions(args.port)) || "{}") + '');
                            sessionInfo = sessionInfos.value.filter(value => args.sessionId ? args.sessionId === value.id : true)[0];
                            if (!sessionInfo || !sessionInfo.id) {
                                utils_1.logError("No suitable session info found", sessionInfo);
                                process.exit(1);
                            }
                            else {
                                args.sessionId = sessionInfo.id;
                                yield driver.attach(args.sessionId);
                                sessionInfoDetails = yield driver.sessionCapabilities();
                            }
                            args.appiumCaps = sessionInfo.capabilities;
                            if (sessionInfo.capabilities.automationName) {
                                args.setAutomationNameFromString(sessionInfo.capabilities.automationName);
                            }
                            utils_1.prepareApp(args);
                            if (!args.device) {
                                if (args.isAndroid) {
                                    args.device = device_manager_1.DeviceManager.getDefaultDevice(args, sessionInfo.capabilities.desired.deviceName, sessionInfo.capabilities.deviceUDID.replace("emulator-", ""), sessionInfo.capabilities.deviceUDID.includes("emulator") ? mobile_devices_controller_1.DeviceType.EMULATOR : mobile_devices_controller_1.DeviceType.SIMULATOR, sessionInfo.capabilities.desired.platformVersion || sessionInfo.capabilities.platformVersion);
                                }
                                else {
                                    args.device = device_manager_1.DeviceManager.getDefaultDevice(args);
                                }
                                args.device = device_manager_1.DeviceManager.applyAppiumSessionInfoDetails(args, sessionInfoDetails);
                            }
                        }
                        else {
                            sessionInfo = yield driver.init(args.appiumCaps);
                            sessionInfoDetails = yield driver.sessionCapabilities();
                            args.device = device_manager_1.DeviceManager.applyAppiumSessionInfoDetails(args, sessionInfoDetails);
                        }
                    }
                    catch (error) {
                        args.verbose = true;
                        if (!args.ignoreDeviceController && error && error.message && error.message.includes("Failure [INSTALL_FAILED_INSUFFICIENT_STORAGE]")) {
                            yield device_manager_1.DeviceManager.kill(args.device);
                            yield mobile_devices_controller_1.DeviceController.startDevice(args.device);
                        }
                    }
                    utils_1.logInfo("Session info: ");
                    console.info(sessionInfoDetails);
                    try {
                        utils_1.logInfo("Appium settings: ");
                        console.log(yield driver.settings());
                    }
                    catch (error) {
                        utils_1.logInfo("Current version of appium doesn't support appium settings!");
                    }
                    yield device_manager_1.DeviceManager.applyDeviceAdditionsSettings(driver, args, sessionInfoDetails);
                    hasStarted = true;
                }
                catch (error) {
                    console.log(error);
                    console.log("Retry launching appium driver!");
                    hasStarted = false;
                    if (error && error.message && error.message.includes("WebDriverAgent")) {
                        const freePort = yield utils_1.findFreePort(100, args.wdaLocalPort);
                        console.log("args.appiumCaps['wdaLocalPort']", freePort);
                        args.appiumCaps["wdaLocalPort"] = freePort;
                    }
                }
                if (hasStarted) {
                    console.log("Appium driver has started successfully!");
                    if (utils_1.checkImageLogType(args.testReporter, log_image_type_1.LogImageType.screenshots)) {
                        args.testReporterLog(`appium_driver_started`);
                        args.testReporterLog(screenshot_manager_1.screencapture(`${args.reportsPath}/appium_driver_started.png`));
                    }
                }
                else {
                    utils_1.logError("Appium driver is NOT started!");
                    if (utils_1.checkImageLogType(args.testReporter, log_image_type_1.LogImageType.screenshots)) {
                        utils_1.ensureReportsDirExists(args);
                        args.testReporterLog(`appium_driver_boot_failure`);
                        args.testReporterLog(screenshot_manager_1.screencapture(`${args.reportsPath}/appium_driver_boot_failure.png`));
                    }
                }
                retries--;
            }
            try {
                if (appiumCapsFromConfig && appiumCapsFromConfig.settings) {
                    appiumCapsFromConfig.settings = JSON.parse(appiumCapsFromConfig.settings);
                }
            }
            catch (error) { }
            if (appiumCapsFromConfig && appiumCapsFromConfig.settings) {
                yield driver.updateSettings(appiumCapsFromConfig.settings);
            }
            if (+sessionInfoDetails.statBarHeight === 0
                && sessionInfoDetails.platformName.toLowerCase() === "ios"
                && sessionInfoDetails.platformVersion.startsWith("13")) {
                try {
                    const devicesInfos = mobile_devices_controller_1.IOSController.devicesDisplaysInfos()
                        .filter(d => sessionInfoDetails.deviceName.includes(d.deviceType));
                    if (devicesInfos.length > 0) {
                        // sort devices by best match - in case we have iPhone XR 13 -> it will match device type 'iPhone X' and 'iPhone XR' -> after sort we will pick first longest match
                        devicesInfos
                            .sort((a, b) => {
                            return sessionInfoDetails.deviceName.replace(a.deviceType, "").length - sessionInfoDetails.deviceName.replace(b.deviceType, "").length;
                        });
                        const deviceType = devicesInfos[0];
                        args.device.viewportRect.y += deviceType.actionBarHeight;
                        args.device.viewportRect.height -= deviceType.actionBarHeight;
                    }
                }
                catch (error) { }
            }
            const appiumDriver = new AppiumDriver(driver, wd, webio, args.driverConfig, args);
            return appiumDriver;
        });
    }
    updateSettings(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            this.driver.updateSettings(settings);
        });
    }
    /**
     *
     * @param xPath
     * @param waitForElement
     */
    findElementByXPath(xPath, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const searchM = "waitForElementByXPath";
            return new ui_element_1.UIElement(yield this._driver.waitForElementByXPath(xPath, waitForElement), this._driver, this._wd, this._webio, this._args, searchM, xPath);
        });
    }
    /**
     *
     * @param xPath
     * @param waitForElement
     */
    findElementsByXPath(xPath, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.convertArrayToUIElements(yield this._driver.waitForElementsByXPath(xPath, waitForElement), "waitForElementsByXPath", xPath);
        });
    }
    /**
     * Search for element by given text. The search is case insensitive for android
     * @param text
     * @param match
     * @param waitForElement
     */
    findElementByText(text, match = search_options_1.SearchOptions.exact, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldMatch = match === search_options_1.SearchOptions.exact ? true : false;
            return yield this.findElementByXPath(this._elementHelper.getXPathByText(text, shouldMatch), waitForElement);
        });
    }
    /**
     * Search for element by given automationText. Searches only for exact string.
     * @param text
     * @param waitForElement
     */
    findElementByAutomationText(automationText, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isIOS) {
                return yield this.findElementByAccessibilityId(`${automationText}`, waitForElement);
            }
            return yield this.findElementByXPath(this._elementHelper.getXPathByText(automationText, true), waitForElement);
        });
    }
    /**
     * Search for element by given automationText. Searches only for exact string.
     * @param text
     * @param waitForElement
    */
    findElementByAutomationTextIfExists(automationText, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isIOS) {
                return yield this.findElementByAccessibilityIdIfExists(`${automationText}`, waitForElement);
            }
            return yield this.findElementByXPathIfExists(this._elementHelper.getXPathByText(automationText, true), waitForElement);
        });
    }
    /**
     * Search for element by given automationText and waits until the element is displayed.
     * @param text
     * @param waitInMilliseconds till element is displayed
     */
    waitForElement(automationText, waitInMilliseconds = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            let element;
            try {
                element = yield this.findElementByAutomationTextIfExists(automationText, 100);
            }
            catch (error) { }
            const startTime = Date.now();
            while ((!element || !(yield element.isDisplayed())) && Date.now() - startTime <= waitInMilliseconds) {
                try {
                    element = yield this.findElementByAutomationTextIfExists(automationText, 100);
                }
                catch (error) { }
            }
            if (!element || !(yield element.isDisplayed())) {
                const msg = `Element with automationText: '${automationText}' is not displayed after ${waitInMilliseconds} milliseconds.`;
                utils_1.logInfo(msg);
            }
            return element;
        });
    }
    /**
     * Search for elements by given automationText. Searches only for exact string. Returns promise with array of elements.
     * @param text
     * @param waitForElement
     */
    findElementsByAutomationText(automationText, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isIOS) {
                return yield this.findElementsByAccessibilityId(`${automationText}`);
            }
            return yield this.findElementsByXPath(this._elementHelper.getXPathByText(automationText, true), waitForElement);
        });
    }
    /**
     * Search for elements by given text. The search is case insensitive for android
     * @param text
     * @param match
     * @param waitForElement
     */
    findElementsByText(text, match = search_options_1.SearchOptions.exact, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldMatch = match === search_options_1.SearchOptions.exact ? true : false;
            return yield this.findElementsByXPath(this._elementHelper.getXPathByText(text, shouldMatch), waitForElement);
        });
    }
    /**
     * Searches for element by element native class name like button, textView etc which will be translated to android.widgets.Button or XCUIElementTypeButton (iOS 10 and higher) or UIElementButton (iOS 9)
     * Notice this is not the same as css class
     * @param className
     * @param waitForElement
     */
    findElementByClassName(className, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            return new ui_element_1.UIElement(yield this._driver.waitForElementByClassName(className, waitForElement), this._driver, this._wd, this._webio, this._args, "waitForElementByClassName", className);
        });
    }
    /**
     * Searches for element by element native class name like button, textView etc which will be translated to android.widgets.Button or XCUIElementTypeButton (iOS 10 and higher) or UIElementButton (iOS 9)
     * Notice this is not the same as css class
     * @param className
     * @param waitForElement
     */
    findElementsByClassName(className, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.convertArrayToUIElements(yield this._driver.waitForElementsByClassName(className, waitForElement), "waitForElementsByClassName", className);
        });
    }
    /**
     * Find element by automationText
     * @param id
     * @param waitForElement
     */
    findElementByAccessibilityId(id, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            return new ui_element_1.UIElement(yield this._driver.waitForElementByAccessibilityId(id, waitForElement), this._driver, this._wd, this._webio, this._args, "waitForElementByAccessibilityId", id);
        });
    }
    /**
     * Find elements by automationText
     * @param id
     * @param waitForElement
     */
    findElementsByAccessibilityId(id, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.convertArrayToUIElements(yield this._driver.waitForElementsByAccessibilityId(id, waitForElement), "waitForElementsByAccessibilityId", id);
        });
    }
    /**
     * Scrolls from point to other point with minimum inertia
     * @param direction
     * @param y
     * @param x
     * @param yOffset
     * @param xOffset
     */
    scroll(direction, y, x, yOffset, xOffset = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            yield utils_1.scroll(this._wd, this._driver, direction, this._webio.isIOS, y, x, yOffset, xOffset, this._args.verbose);
        });
    }
    /**
     *
     * @param direction
     * @param element
     * @param startPoint
     * @param yOffset
     * @param xOffset
     * @param retryCount
     */
    scrollTo(direction, element, startPoint, offsetPoint, retryCount = 7) {
        return __awaiter(this, void 0, void 0, function* () {
            let el = null;
            let isDisplayed = false;
            while ((el === null || !isDisplayed) && retryCount > 0) {
                try {
                    el = yield element();
                    isDisplayed = yield el.isDisplayed();
                    if (!isDisplayed) {
                        yield utils_1.scroll(this._wd, this._driver, direction, this._webio.isIOS, startPoint.y, startPoint.x, offsetPoint.x, offsetPoint.y, this._args.verbose);
                        el = null;
                    }
                }
                catch (error) {
                    console.log("scrollTo Error: " + error);
                }
                retryCount--;
            }
            return el;
        });
    }
    /**
     * Swipe from point with offset and inertia according to duration
     * @param y
     * @param x
     * @param yOffset
     * @param inertia
     * @param xOffset
     */
    swipe(startPoint, endPoint, inertia) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!inertia) {
                inertia = (Math.abs(startPoint.x - endPoint.x) > Math.abs(endPoint.y - startPoint.y)
                    ? Math.abs(startPoint.x - endPoint.x) : Math.abs(endPoint.y - startPoint.y))
                    * 10;
            }
            new this._wd.TouchAction(this._driver)
                .press({ x: startPoint.x, y: startPoint.y })
                .wait(inertia)
                .moveTo({ x: endPoint.x, y: endPoint.y })
                .release()
                .perform();
            yield this._driver.sleep(150);
        });
    }
    /**
    * Click a point by providing coordinates
    * @param x
    * @param y
    */
    clickPoint(xCoordinate, yCoordinate) {
        return __awaiter(this, void 0, void 0, function* () {
            let action = new this._wd.TouchAction(this._driver);
            action
                .tap({ x: xCoordinate, y: yCoordinate });
            yield action.perform();
            yield this._driver.sleep(150);
        });
    }
    getOrientation() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._driver.getOrientation();
        });
    }
    setOrientation(orientation) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.logInfo(`Set device orientation: ${orientation}`);
            yield this._driver.setOrientation(orientation);
            if (orientation === device_orientation_1.DeviceOrientation.LANDSCAPE && this.isAndroid) {
                if (this.nsCapabilities.automationName === automation_name_1.AutomationName.UiAutomator1
                    || this.nsCapabilities.automationName === automation_name_1.AutomationName.Appium) {
                    // HACK since the image is rotated and action bar is on the bottom of the image, it is needed to exclude action bar from bottom.
                    const height = this._imageHelper.options.cropRectangle.width - this._imageHelper.options.cropRectangle.y;
                    const width = this._imageHelper.options.cropRectangle.height + this._imageHelper.options.cropRectangle.y;
                    this.imageHelper.options.cropRectangle.y = 0;
                    this.imageHelper.options.cropRectangle.width = width;
                    this.imageHelper.options.cropRectangle.height = height;
                }
                else if (this.nsCapabilities.automationName === automation_name_1.AutomationName.UiAutomator2) {
                    const height = this._imageHelper.options.cropRectangle.width - this.imageHelper.options.cropRectangle.y;
                    const width = this._imageHelper.options.cropRectangle.height + this.imageHelper.options.cropRectangle.y;
                    this.imageHelper.options.cropRectangle.width = width;
                    this.imageHelper.options.cropRectangle.height = height;
                }
            }
            else if (orientation === device_orientation_1.DeviceOrientation.LANDSCAPE && this.isIOS) {
                this.imageHelper.options.cropRectangle.x = 0;
                const height = this._imageHelper.options.cropRectangle.width;
                const width = this._imageHelper.options.cropRectangle.height + this._imageHelper.options.cropRectangle.y;
                this.imageHelper.options.cropRectangle.y = 0;
                this.imageHelper.options.cropRectangle.width = width;
                this.imageHelper.options.cropRectangle.height = height;
            }
            else {
                this.imageHelper.resetDefaultOptions();
            }
        });
    }
    source() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._driver.source();
        });
    }
    sessionId() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.driver.getSessionId();
        });
    }
    compareElement(element, imageName, tolerance = this.imageHelper.defaultTolerance, timeOutSeconds = 3, toleranceType = this.imageHelper.defaultToleranceType) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.compareRectangle(yield element.getActualRectangle(), imageName, timeOutSeconds, tolerance, toleranceType);
        });
    }
    compareRectangle(rect, imageName, timeOutSeconds = 3, tolerance = this.imageHelper.defaultTolerance, toleranceType = this.imageHelper.defaultToleranceType) {
        return __awaiter(this, void 0, void 0, function* () {
            imageName = imageName || this.imageHelper.testName;
            const options = this.imageHelper.extendOptions({
                imageName: imageName,
                timeOutSeconds: timeOutSeconds,
                tolerance: tolerance,
                cropRectangle: rect,
                toleranceType: toleranceType,
                keepOriginalImageName: true,
                keepOriginalImageSize: false
            });
            return yield this.imageHelper.compare(options);
        });
    }
    compareScreen(imageName, timeOutSeconds = 3, tolerance = this.imageHelper.defaultTolerance, toleranceType = this.imageHelper.defaultToleranceType) {
        return __awaiter(this, void 0, void 0, function* () {
            imageName = imageName || this.imageHelper.testName;
            const options = this.imageHelper.extendOptions({
                imageName: imageName,
                timeOutSeconds: timeOutSeconds,
                tolerance: tolerance,
                toleranceType: toleranceType,
                keepOriginalImageName: true
            });
            return yield this.imageHelper.compare(options);
        });
    }
    /**
     * @param videoName
     * @param callback when to stop video recording. In order an element is found. Should return true to exit
     */
    recordVideo(videoName, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            return mobile_devices_controller_1.DeviceController.recordVideo(this._args.device, this._args.storageByDeviceName, videoName, callback);
        });
    }
    /**
     * @param videoName
     */
    startRecordingVideo(videoName) {
        videoName = videoName.replace(/\s/gi, "");
        console.log("DEVICE: ", this._args.device);
        this._recordVideoInfo = mobile_devices_controller_1.DeviceController.startRecordingVideo(this._args.device, this._args.reportsPath, videoName);
        this._recordVideoInfo['device'] = this._args.device;
        return this._recordVideoInfo['pathToVideo'];
    }
    stopRecordingVideo() {
        this._recordVideoInfo['videoRecordingProcess'].kill("SIGINT");
        utils_1.wait(this.isIOS ? 100 : 10000);
        if (this._args.device.type === mobile_devices_controller_1.DeviceType.EMULATOR || this._args.device.platform === mobile_devices_controller_1.Platform.ANDROID) {
            mobile_devices_controller_1.AndroidController.pullFile(this._recordVideoInfo['device'], this._recordVideoInfo['devicePath'], this._recordVideoInfo['pathToVideo'].endsWith(".mp4") ? this._recordVideoInfo['pathToVideo'] : `${this._recordVideoInfo['pathToVideo']}.mp4`);
            utils_1.wait(20000);
        }
        return Promise.resolve(this._recordVideoInfo['pathToVideo']);
    }
    takeScreenshot(fileName) {
        if (!fileName.endsWith(image_helper_1.ImageHelper.pngFileExt)) {
            fileName = fileName.concat(image_helper_1.ImageHelper.pngFileExt);
        }
        return new Promise((resolve, reject) => {
            this._driver.takeScreenshot(fileName).then(function (image, err) {
                if (err) {
                    console.error(err);
                    reject(err);
                }
                fs_1.writeFileSync(fileName, image, 'base64');
                resolve(fileName);
            });
        });
    }
    saveScreenshot(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fileName.endsWith(image_helper_1.ImageHelper.pngFileExt)) {
                fileName = fileName.concat(image_helper_1.ImageHelper.pngFileExt);
            }
            return yield this._driver.saveScreenshot(fileName);
        });
    }
    testReporterLog(log) {
        if (this._args.testReporterLog) {
            return this._args.testReporterLog(log);
        }
        return undefined;
    }
    logScreenshot(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fileName.endsWith(image_helper_1.ImageHelper.pngFileExt)) {
                fileName = fileName.concat(image_helper_1.ImageHelper.pngFileExt).replace(/\s+/ig, "_");
            }
            if (Object.getOwnPropertyNames(this._args.testReporter).length > 0) {
                this.testReporterLog(fileName.replace(/\.\w+/ig, ""));
                fileName = path_1.join(this._args.reportsPath, fileName);
                fileName = this.testReporterLog(fileName);
            }
            fileName = utils_1.resolvePath(this._args.reportsPath, fileName);
            const imgPath = yield this.saveScreenshot(fileName);
            return imgPath;
        });
    }
    getlog(logType) {
        return __awaiter(this, void 0, void 0, function* () {
            const logs = yield this._driver.log(logType);
            return logs;
        });
    }
    logPageSource(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fileName.endsWith(".xml")) {
                fileName = fileName.concat(".xml");
            }
            const path = utils_1.resolvePath(this._args.reportsPath, fileName);
            const xml = yield this.source();
            fs_1.writeFileSync(path, xml, 'utf8');
        });
    }
    logDeviceLog(fileName, logType, filter = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            let logs;
            try {
                logs = yield this.getlog(logType);
            }
            catch (error) {
                utils_1.logError(`Failed to get log type: ${logType}`);
            }
            let deviceLog = "";
            logs.forEach(log => {
                const currentLog = `\n${JSON.stringify(log)}`;
                if (filter) {
                    if (currentLog.includes(filter)) {
                        deviceLog += `\n${JSON.stringify(log)}`;
                    }
                }
                else {
                    deviceLog += `\n${JSON.stringify(log)}`;
                }
            });
            if (logs.length > 0 && deviceLog) {
                const ext = path_1.extname(fileName);
                fileName = fileName.replace(ext, "");
                fileName = fileName.concat('_').concat(logType);
                fileName = fileName.concat(".log");
                const path = utils_1.resolvePath(this._args.reportsPath, fileName);
                fs_1.writeFileSync(path, deviceLog, 'utf8');
            }
            else {
                console.log(`Log type: ${logType} is empty!`);
            }
        });
    }
    /**
     * This method will snapshot the screen of device, get page source and log from device
     * @param logName
     */
    logTestArtifacts(logName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.logScreenshot(logName);
            yield this.logPageSource(logName);
            if (this.isAndroid) {
                yield this.logDeviceLog(logName, log_types_1.LogType.logcat);
            }
            else {
                yield this.logDeviceLog(logName, log_types_1.LogType.crashlog);
                yield this.logDeviceLog(logName, log_types_1.LogType.syslog);
            }
        });
    }
    /**
     * Send the currently active app to the background
     * @param time in seconds
     */
    backgroundApp(seconds) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.logInfo("Sending the currently active app to the background ...");
            this._args.testReporterLog("Sending the currently active app to the background ...");
            yield this._driver.backgroundApp(seconds);
        });
    }
    /**
     * Hides device keyboard
     */
    hideDeviceKeyboard() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._driver.hideDeviceKeyboard();
            }
            catch (error) { }
        });
    }
    isKeyboardShown() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._driver.isKeyboardShown();
        });
    }
    resetApp() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._driver.resetApp();
        });
    }
    // restart app
    restartApp() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._driver.closeApp();
            }
            catch (error) {
                utils_1.logError("Current appium version doesn't support closeApp()!");
                utils_1.logError("Consider to use resetApp()! Reset app will reinstall the application");
            }
            try {
                yield this._driver.launchApp();
            }
            catch (error) {
                utils_1.logError("Current appium version doesn't support launchApp()!");
                utils_1.logError("Consider to use resetApp()! Reset app will reinstall the application");
            }
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._driver.init(this._args.appiumCaps);
            this._webio.requestHandler.sessionID = this._driver.sessionID;
            this._isAlive = true;
        });
    }
    quit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._recordVideoInfo && this._recordVideoInfo['videoRecordingProcess']) {
                this._recordVideoInfo['videoRecordingProcess'].kill("SIGINT");
            }
            try {
                if (!this._args.attachToDebug) {
                    console.log("Killing driver...");
                    yield this._driver.quit();
                    this._isAlive = false;
                    console.log("Driver is dead!");
                    if (utils_1.checkImageLogType(this._args.testReporter, log_image_type_1.LogImageType.screenshots)) {
                        this._args.testReporterLog(`appium_driver_quit`);
                        this._args.testReporterLog(screenshot_manager_1.screencapture(`${this._args.reportsPath}/appium_driver_quit.png`));
                    }
                }
                else {
                    //await this._webio.detach();
                }
            }
            catch (error) {
                if (this._args.verbose) {
                    if (utils_1.checkImageLogType(this._args.testReporter, log_image_type_1.LogImageType.screenshots)) {
                        this._args.testReporterLog(`appium_driver_quit_failure`);
                        this._args.testReporterLog(screenshot_manager_1.screencapture(`${this._args.reportsPath}/appium_driver_quit_failure.png`));
                    }
                    console.dir(error);
                }
            }
        });
    }
    static applyAdditionalSettings(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.isSauceLab)
                return;
            args.appiumCaps['udid'] = args.appiumCaps['udid'] || args.device.token;
            if (args.device.type === mobile_devices_controller_1.DeviceType.EMULATOR && args.device.token) {
                args.appiumCaps['udid'] = args.device.token.startsWith("emulator") ? args.device.token : `emulator-${args.device.token}`;
            }
            if (!args.appiumCaps['udid']) {
                delete args.appiumCaps['udid'];
            }
            if (args.appiumCaps.platformName.toLowerCase() === mobile_devices_controller_1.Platform.IOS) {
                args.appiumCaps["useNewWDA"] = args.appiumCaps.useNewWDA;
                args.appiumCaps["wdaStartupRetries"] = 5;
                args.appiumCaps["shouldUseSingletonTestManager"] = args.appiumCaps.shouldUseSingletonTestManager;
                // It looks we need it for XCTest (iOS 10+ automation)
                if (args.appiumCaps.platformVersion >= 10 && args.wdaLocalPort) {
                    console.log(`args.appiumCaps['wdaLocalPort']: ${args.wdaLocalPort}`);
                    args.appiumCaps["wdaLocalPort"] = args.wdaLocalPort;
                }
            }
            else {
                if (process.env["SYSTEM_PORT"]) {
                    args.appiumCaps['systemPort'] = process.env["SYSTEM_PORT"];
                }
            }
        });
    }
    convertArrayToUIElements(array, searchM, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const arrayOfUIElements = new Array();
            if (!array || array === null) {
                return arrayOfUIElements;
            }
            for (let index = 0; index < array.length; index++) {
                const element = array[index];
                arrayOfUIElements.push(new ui_element_1.UIElement(yield element, this._driver, this._wd, this._webio, this._args, searchM, args, index));
            }
            return arrayOfUIElements;
        });
    }
    static configureLogging(driver, verbose) {
        driver.on("status", function (info) {
            utils_1.log(info, verbose);
        });
        driver.on("quit", function (info) {
            console.log("QUIT: ", info);
        });
        driver.on("command", function (meth, path, data) {
            utils_1.log(" > " + meth + " " + path + " " + (data || ""), verbose);
        });
        driver.on("http", function (meth, path, data) {
            utils_1.log(" > " + meth + " " + path + " " + (data || ""), verbose);
        });
    }
    ;
    /**
    * Wait specific amount of time before continue execution
    * @param milliseconds
    */
    sleep(milliseconds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._driver.sleep(milliseconds);
        });
    }
    /**
  * Wait specific amount of time before continue execution
  * @param milliseconds
  */
    wait(milliseconds) {
        utils_1.wait(milliseconds);
    }
    /**
    * Search for element by given xPath but does not throw error if can not find it. Instead returns 'undefined'.
    * @param xPath
    * @param waitForElement
    */
    findElementByXPathIfExists(xPath, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const element = yield this._driver.elementByXPathIfExists(xPath, waitForElement);
            if (element) {
                const searchMethod = "elementByXPathIfExists";
                return new ui_element_1.UIElement(element, this._driver, this._wd, this._webio, this._args, searchMethod, xPath);
            }
            else {
                return undefined;
            }
        });
    }
    /**
    * Search for element by given text but does not throw error if can not find it. Instead returns 'undefined'.
    * @param text
    * @param match
    * @param waitForElement
    */
    findElementByTextIfExists(text, match = search_options_1.SearchOptions.exact, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldMatch = match === search_options_1.SearchOptions.exact ? true : false;
            return yield this.findElementByXPathIfExists(this._elementHelper.getXPathByText(text, shouldMatch), waitForElement);
        });
    }
    /**
    * Search for element by automationText but does not throw error if can not find it. Instead returns 'undefined'.
    * @param id
    * @param waitForElement
    */
    findElementByAccessibilityIdIfExists(id, waitForElement = this.defaultWaitTime) {
        return __awaiter(this, void 0, void 0, function* () {
            let element = undefined;
            try {
                element = yield this._driver.elementByAccessibilityIdIfExists(id, waitForElement);
            }
            catch (error) { }
            if (element) {
                const searchMethod = "elementByAccessibilityIdIfExists";
                return yield new ui_element_1.UIElement(element, this._driver, this._wd, this._webio, this._args, searchMethod, id);
            }
            return element;
        });
    }
    setDontKeepActivities(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._args.isAndroid) {
                const output = yield device_manager_1.DeviceManager.setDontKeepActivities(this._args, this._driver, value);
            }
            else {
                // Do nothing for iOS ...
            }
        });
    }
    /**
     *  Experimental feature that is still tricky to use!!!
     *  Find location on the screen by provided image.
     * @param image The name of the image without the extension.
     * @param imageThreshold The degree of match for current search, on the scale between 0 and 1. Default 0.4
     */
    findElementByImage(image, imageThreshold = 0.4) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._driver.updateSettings({ imageMatchThreshold: imageThreshold });
            const imageName = utils_1.addExt(image, image_helper_1.ImageHelper.pngFileExt);
            const pathExpectedImage = this._imageHelper.getExpectedImagePathByDevice(imageName);
            if (!fs_1.existsSync(pathExpectedImage)) {
                throw new Error("The provided image does not exist!!!");
            }
            const imageAsBase64 = utils_1.encodeImageToBase64(pathExpectedImage);
            let searchResult;
            try {
                searchResult = yield this._driver.elementByImage(imageAsBase64);
            }
            catch (error) {
                throw new Error(error);
            }
            finally {
                // reset setting to default value
                yield this._driver.updateSettings({ imageMatchThreshold: 0.4 });
            }
            return new ui_element_1.UIElement(searchResult, this._driver, this._wd, this._webio, this._args, "elementByImage", imageAsBase64);
        });
    }
    /**
    * Get screen actual view port
    * Useful for image comparison
    */
    getScreenActualViewPort() {
        return (this._args.device.viewportRect || this.imageHelper.options.cropRectangle);
    }
    /**
    * Get screen view port.
    * Provides the view port that is needed for some gestures like swipe etc.
    */
    getScreenViewPort() {
        const rect = this.getScreenActualViewPort();
        if (rect
            && this.isIOS
            && Object.getOwnPropertyNames(rect).length > 0
            && this._args.device.deviceScreenDensity) {
            return {
                x: rect.x / this._args.device.deviceScreenDensity,
                y: rect.y / this._args.device.deviceScreenDensity,
                width: rect.width / this._args.device.deviceScreenDensity,
                height: rect.height / this._args.device.deviceScreenDensity,
            };
        }
        else {
            return rect;
        }
    }
    /**
    * Android ONLY! Input key event via ADB.
    * Must be combined with '--relaxed-security' appium flag. When not running in sauceLabs '--ignoreDeviceController' should be added too.
    * @param keyEvent The event number
    */
    adbKeyEvent(keyEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.adbShellCommand("input", ["keyevent", keyEvent]);
        });
    }
    /**
    * Android ONLY! Send text via ADB.
    * Must be combined with '--relaxed-security' appium flag. When not running in sauceLabs '--ignoreDeviceController' should be added too.
    * @param text The string to send
    */
    adbSendText(text) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.adbShellCommand("input", ["text", text]);
        });
    }
    /**
    * Android ONLY! Execute shell command via ADB.
    * Must be combined with '--relaxed-security' appium flag. When not running in sauceLabs '--ignoreDeviceController' should be added too.
    * @param command The command name
    * @param args Additional arguments
    */
    adbShellCommand(command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield utils_1.adbShellCommand(this._driver, command, args);
        });
    }
}
exports.AppiumDriver = AppiumDriver;
//# sourceMappingURL=appium-driver.js.map