"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = require("child_process");
const glob = require("glob");
const http = require("http");
const mobile_devices_controller_1 = require("mobile-devices-controller");
const point_1 = require("./point");
const fs_1 = require("fs");
const path_1 = require("path");
function resolvePath(mainPath, ...args) {
    if (!path_1.isAbsolute(mainPath) && mainPath.startsWith('~')) {
        mainPath = mainPath.replace("~", process.env.HOM);
    }
    const fullPath = path_1.resolve(mainPath, ...args);
    return fullPath;
}
exports.resolvePath = resolvePath;
function isDirectory(fullName) {
    try {
        if (fs_1.existsSync(fullName) && fs_1.statSync(fullName).isDirectory()) {
            return true;
        }
    }
    catch (e) {
        console.log(e.message);
        return false;
    }
    return false;
}
exports.isDirectory = isDirectory;
function isFile(fullName) {
    try {
        if (fs_1.existsSync(fullName) && fs_1.statSync(fullName).isFile()) {
            return true;
        }
    }
    catch (e) {
        logError(e.message, true);
        return false;
    }
    return false;
}
exports.isFile = isFile;
function copy(src, dest, verbose) {
    if (!fs_1.existsSync(src)) {
        return Error("Cannot copy: " + src + ". Source doesn't exist: " + dest);
    }
    if (fs_1.existsSync(src) && isFile(src) && isDirectory(dest)) {
        dest = path_1.join(dest, path_1.basename(src));
    }
    if (isDirectory(src)) {
        if (!fs_1.existsSync(dest)) {
            console.info("CREATE Directory: " + dest);
            fs_1.mkdirSync(dest);
        }
        const files = getAllFileNames(src);
        const destination = dest;
        files.forEach(file => {
            const newFileDest = resolvePath(destination, file);
            copy(path_1.join(src, file), newFileDest, verbose);
        });
    }
    else {
        fs_1.writeFileSync(dest, fs_1.readFileSync(src));
    }
    if (verbose) {
        console.info("File " + src + " is copied to " + dest);
    }
    return dest;
}
exports.copy = copy;
function getAllFileNames(folder) {
    let files = new Array();
    fs_1.readdirSync(resolvePath(folder)).forEach(file => {
        files.push(file);
    });
    return files;
}
/// ^nativ\w*(.+).gz$ native*.gz
/// \w*nativ\w*(.+)\.gz$ is like *native*.gz
/// \w*nativ\w*(.+)\.gz\w*(.+)$ is like *native*.gz*
// function createRegexPattern(text) {
//     let finalRex = "";
//     text.split(",").forEach(word => {
//         word = word.trim();
//         let searchRegex = word;
//         if (word !== "" && word !== " ") {
//             searchRegex = searchRegex.replace(".", "\\.");
//             searchRegex = searchRegex.replace("*", "\\w*(.+)?");
//             if (!word.startsWith("*")) {
//                 searchRegex = "^" + searchRegex;
//             }
//             if (!word.endsWith("*")) {
//                 searchRegex += "$";
//             }
//             if (finalRex.indexOf(searchRegex) < 0) {
//                 finalRex += searchRegex + "|";
//             }
//         }
//     });
//     finalRex = finalRex.substring(0, finalRex.length - 1);
//     const regex = new RegExp(finalRex, "gi");
//     return regex;
// }
// Search for files and folders. If should not match, than the filter will skip this words. Could be use with wildcards
// export function searchFiles(folder, words, recursive: boolean = true, files = new Array()): Array<string> {
//     const rootFiles = getAllFileNames(folder);
//     const regex = createRegexPattern(words);
//     rootFiles.filter(f => {
//         const fileFullName = resolve(folder, f);
//         let m = regex.test(f);
//         if (m) {
//             files.push(fileFullName);
//         } else if (isDirectory(fileFullName) && recursive) {
//             searchFiles(fileFullName, words, recursive, files);
//         }
//     });
//     return files;
// }
function shutdown(processToKill, verbose) {
    try {
        if (processToKill && processToKill !== null) {
            if (isWin()) {
                killPid(processToKill.pid, verbose);
            }
            else {
                processToKill.kill();
            }
            processToKill.killed = true;
            processToKill = null;
            console.log("Shut down!!!");
        }
    }
    catch (error) {
        logError(error, verbose);
    }
}
exports.shutdown = shutdown;
function killPid(pid, verbose) {
    let output = childProcess.execSync('taskkill /PID ' + pid + ' /T /F');
    log(output, verbose);
}
exports.killPid = killPid;
function waitForOutput(process, matcher, errorMatcher, timeout, verbose) {
    return new Promise(function (resolve, reject) {
        const abortWatch = setTimeout(function () {
            process.kill();
            logError("Timeout expired, output not detected for: " + matcher);
            resolve(false);
        }, timeout);
        process.stdout.on("data", function (data) {
            let line = "" + data;
            log(line, verbose);
            if (errorMatcher.test(line)) {
                clearTimeout(abortWatch);
                resolve(false);
            }
            if (matcher.test(line)) {
                clearTimeout(abortWatch);
                resolve(true);
            }
        });
    });
}
exports.waitForOutput = waitForOutput;
function executeCommand(args, cwd = process.cwd()) {
    const commands = args.split(" ");
    const baseCommand = commands.shift();
    const output = childProcess.spawnSync(baseCommand, commands, {
        shell: true,
        cwd: cwd,
        encoding: "UTF8"
    });
    return output.stdout && output.stdout.toString();
}
exports.executeCommand = executeCommand;
function isWin() {
    return /^win/i.test(process.platform);
}
exports.isWin = isWin;
function isMac() {
    return /^darwin/i.test(process.platform);
}
exports.isMac = isMac;
function isLinux() {
    return /^linux/i.test(process.platform);
}
exports.isLinux = isLinux;
const getDeviceName = (args) => {
    const deviceName = (args.attachToDebug || args.sessionId) ? args.device.name : args.appiumCaps.deviceName;
    return deviceName;
};
function getStorageByDeviceName(args) {
    let storage = exports.getStorage(args);
    if (args.imagesPath) {
        const segments = args.imagesPath.split(/[\/\\]+/);
        storage = path_1.join(storage, segments.join(path_1.sep));
        if (fs_1.existsSync(storage)) {
            logInfo(`Images storage set to: ${storage}!`);
            return storage;
        }
        else {
            const error = `Current imagesPath (${args.imagesPath}) does not exist !!!`;
            logError(error);
            throw new Error(error);
        }
    }
    const appName = resolveSauceLabAppName(getAppName(args));
    storage = createStorageFolder(storage, appName);
    storage = createStorageFolder(storage, getDeviceName(args));
    logWarn(`Images storage set to: ${storage}!`);
    return storage;
}
exports.getStorageByDeviceName = getStorageByDeviceName;
function getStorageByPlatform(args) {
    let storage = exports.getStorage(args);
    const appName = resolveSauceLabAppName(getAppName(args));
    storage = createStorageFolder(storage, appName);
    storage = createStorageFolder(storage, args.appiumCaps.platformName.toLowerCase());
    logWarn(`Images storage set to: ${storage}!`);
    return storage;
}
exports.getStorageByPlatform = getStorageByPlatform;
const checkStorageIsUndefined = (storage) => { return !storage || storage === 'undefined' || storage === null || storage === 'null'; };
exports.getStorage = (args) => {
    let storage = args.storage;
    if (checkStorageIsUndefined(storage)) {
        storage = createStorageFolder(resolvePath(args.projectDir, args.testFolder), "resources");
        storage = createStorageFolder(storage, "images");
    }
    logWarn(`STORAGE: ${storage}`);
    return storage;
};
function getReportPath(args) {
    if (Object.getOwnPropertyNames(args.testReporter).length > 0 && args.testReporter.reportDir) {
        return args.testReporter.reportDir;
    }
    let report = args.testReports;
    if (!report) {
        report = createStorageFolder(resolvePath(args.projectDir, args.testFolder), "reports");
    }
    const appName = getAppName(args);
    report = createStorageFolder(report, appName);
    report = createStorageFolder(report, getDeviceName(args));
    return report;
}
exports.getReportPath = getReportPath;
exports.getRegexResultsAsArray = (regex, str) => {
    let m;
    const result = [];
    while ((m = regex.exec(str)) !== null) {
        if (m.index === regex.lastIndex) {
            regex.lastIndex++;
        }
        m.forEach(element => {
            if (result.indexOf(element) < 0) {
                result.push(element);
            }
        });
    }
    return result;
};
function getAppName(args) {
    const appName = args.appName || path_1.basename(args.appPath)
        .replace(path_1.extname(args.appPath), "")
        .replace("-release", "").replace("-debug", "");
    return appName;
}
function getAppPath(caps) {
    let basePath = caps.appiumCaps.app || caps.appPath;
    basePath = basePath && basePath.startsWith("~") ? basePath.replace("~", process.env["HOME"]) : basePath;
    if (basePath) {
        basePath = path_1.resolve(basePath);
    }
    if (fs_1.existsSync(basePath) && ((basePath.endsWith(".apk") || basePath.endsWith(".app") || basePath.endsWith(".ipa")))) {
        return resolvePath(basePath);
    }
    // try to resolve app automatically
    if (!fs_1.existsSync(basePath)) {
        if (caps.isAndroid) {
            const androidPlatformsPath = 'platforms/android';
            //platforms/android/build/outputs/apk/
            //platforms/android/app/build/outputs/apk
            //platforms/android/app/build/outputs/apk
            //   /release
            //   /debug
            basePath = `${androidPlatformsPath}/app/build/outputs/apk/**/*.apk`;
            if (!fs_1.existsSync(`${androidPlatformsPath}/app/build/outputs/apk`)) {
                basePath = `${androidPlatformsPath}/build/outputs/apk/**/*.apk`;
            }
        }
        else {
            const iosPlatformsPath = 'platforms/ios/build';
            // possible paths
            // "Release-iphoneos"
            // "Release-iphonesimulator"
            // "Debug-iphoneos"
            // "Debug-iphonesimulator"
            // "device"
            // "emulator"
            if (caps.device && caps.device.type) {
                basePath = caps.device.type === mobile_devices_controller_1.DeviceType.DEVICE ? `${iosPlatformsPath}/**/*.ipa` : `${iosPlatformsPath}/**/*.app`;
            }
            else if (caps.runType.startsWith("dev")) {
                basePath = `${iosPlatformsPath}/**/*.ipa`;
            }
            else {
                basePath = `${iosPlatformsPath}/**/*.app`;
            }
        }
    }
    let apps = glob.sync(basePath);
    if (!apps || apps.length === 0) {
        if (caps.isAndroid) {
            apps = glob.sync(`${caps.projectDir}/**/*.apk`);
        }
        if (caps.isIOS) {
            if (caps.runType.startsWith("dev")) {
                apps = glob.sync(`${caps.projectDir}/**/*.app`);
            }
            else {
                apps = glob.sync(`${caps.projectDir}/**/*.ipa`);
            }
        }
    }
    if (!apps || apps.length === 0) {
        logError(`No 'app' capability provided or the convention for 'runType'${caps.runType} is not as expected! 
                In order to automatically search and locate app package please use 'device' in your 'runType' name. E.g --runType device.iPhone7.iOS110, --runType sim.iPhone7.iOS110 or
                specify correct app path`);
    }
    logInfo(`Available applications:`, apps);
    logInfo(`Pick first application: `, apps[0]);
    const appFullPath = apps.length > 0 ? resolvePath(apps[0]) : undefined;
    return appFullPath;
}
exports.getAppPath = getAppPath;
function calculateOffset(direction, y, yOffset, x, xOffset, isIOS, verbose) {
    let speed = 10;
    let yEnd = Math.abs(yOffset);
    let xEnd = Math.abs(xOffset);
    let duration = Math.abs(yEnd) * speed;
    if (isIOS) {
        speed = 100;
        if (direction === 0 /* down */) {
            direction = -1;
            yEnd = direction * yEnd;
        }
        if (direction === 3 /* right */) {
            direction = -1;
            xEnd = direction * xEnd;
        }
    }
    else {
        if (direction === 0 /* down */) {
            yEnd = Math.abs(yOffset - y);
        }
        if (direction === 1 /* up */) {
            yEnd = direction * Math.abs((Math.abs(yOffset) + y));
        }
        duration = Math.abs(yOffset) * speed;
        if (direction === 3 /* right */) {
            xEnd = Math.abs(xOffset - x);
        }
        if (direction === 2 /* left */) {
            xEnd = Math.abs(xOffset + x);
        }
        if (yOffset < xOffset && x) {
            duration = Math.abs(xOffset) * speed;
        }
    }
    log({ point: new point_1.Point(xEnd, yEnd), duration: duration }, verbose);
    return { point: new point_1.Point(xEnd, yEnd), duration: duration };
}
exports.calculateOffset = calculateOffset;
/**
 * Scrolls from point to other point with minimum inertia
 * @param y
 * @param x
 * @param yOffset
 * @param xOffset
 */
function scroll(wd, driver, direction, isIOS, y, x, yOffset, xOffset, verbose) {
    return __awaiter(this, void 0, void 0, function* () {
        if (x === 0) {
            x = 20;
        }
        if (y === 0) {
            y = 20;
        }
        const endPoint = calculateOffset(direction, y, yOffset, x, xOffset, isIOS, verbose);
        const action = new wd.TouchAction(driver);
        action
            .press({ x: x, y: y })
            .wait(endPoint.duration)
            .moveTo({ x: endPoint.point.x, y: endPoint.point.y })
            .release();
        yield action.perform();
        yield driver.sleep(150);
    });
}
exports.scroll = scroll;
function createStorageFolder(storage, directory) {
    storage = resolvePath(storage, directory);
    try {
        storage = fs_1.readlinkSync(storage);
    }
    catch (error) { }
    try {
        storage = fs_1.realpathSync(storage);
    }
    catch (error) { }
    if (!fs_1.existsSync(storage)) {
        fs_1.mkdirSync(storage);
    }
    return storage;
}
exports.addExt = (fileName, ext) => { return fileName.endsWith(ext) ? fileName : fileName.concat(ext); };
exports.isPortAvailable = (port) => {
    const net = require('net');
    return new Promise(resolve => {
        if (isNaN(port) || port != parseInt(port) || port < 0 || port > 65536) {
            // const err = 'Invalid input. Port must be an Integer number between 0 and 65536';
            // console.error(err);
            resolve(false);
        }
        port = parseInt(port);
        const tester = net.createServer()
            .once('error', err => {
            //console.error("Error: ", err);
            resolve(false);
        })
            .once('listening', () => tester.once('close', () => resolve(true)).close())
            .listen(port);
    });
};
exports.findFreePort = (retries = 10, port = 3000) => __awaiter(this, void 0, void 0, function* () {
    let p = port;
    while (!(yield exports.isPortAvailable(p)) && retries > 0) {
        p += 10;
        retries--;
    }
    return p;
});
function wait(milliseconds) {
    const startTime = Date.now();
    while (Date.now() - startTime <= milliseconds) {
    }
    return;
}
exports.wait = wait;
function resolveSauceLabAppName(appName) {
    return appName.includes("sauce-storage:") ? appName.replace("sauce-storage:", "") : appName;
}
function getSessions(port, host = `0.0.0.0`) {
    return new Promise((resolve, reject) => {
        http.get(`http://localhost:${port}/wd/hub/sessions`, (resp) => {
            let data = '';
            // A chunk of data has been received.
            resp.on('data', (chunk) => {
                data += chunk;
            });
            // The whole response has been received. Print out the result.
            resp.on('end', () => {
                let result = undefined;
                console.log(data);
                try {
                    //result = JSON.parse(data);
                    result = data;
                }
                catch (error) {
                }
                resolve(result);
            });
        }).on("error", (err) => {
            console.log("Error: " + err.message);
            resolve(undefined);
        });
    });
}
exports.getSessions = getSessions;
exports.prepareDevice = (args, deviceManager) => __awaiter(this, void 0, void 0, function* () {
    if (!args.device) {
        const device = yield deviceManager.startDevice(args);
        args.device = device;
        if (!args.ignoreDeviceController) {
            args.appiumCaps.deviceName = device.name;
            args.appiumCaps.udid = device.type === mobile_devices_controller_1.DeviceType.EMULATOR ? `emulator-${device.token}` : device.token;
            args.appiumCaps.platformVersion = device.apiLevel;
        }
    }
    return args;
});
exports.prepareApp = (args) => __awaiter(this, void 0, void 0, function* () {
    const appPackage = args.isAndroid ? "appPackage" : "bundleId";
    const appFullPath = args.appiumCaps.app;
    if (!args.ignoreDeviceController && !args.attachToDebug && !args.sessionId) {
        if (appFullPath && !args.appiumCaps[appPackage]) {
            console.log(`Trying to resolve automatically ${appPackage}!`);
            args.appiumCaps[appPackage] = args.deviceManager.getPackageId(args.device, appFullPath);
            console.log(`Setting capabilities ${args.runType}{ "${appPackage}" : "${args.appiumCaps[appPackage]}" }!`);
        }
        const appActivityProp = "appActivity";
        if (args.isAndroid && appFullPath && !args.appiumCaps[appActivityProp]) {
            console.log(`Trying to resolve automatically ${appActivityProp}!`);
            args.appiumCaps[appActivityProp] = mobile_devices_controller_1.AndroidController.getLaunchableActivity(appFullPath);
            console.log(`Setting capabilities ${args.runType}{ "${appActivityProp} : "${args.appiumCaps[appActivityProp]}" }!`);
        }
        if (!args.appiumCaps[appPackage]) {
            logError(`Please, provide ${appPackage} in ${args.appiumCapsLocation} file!`);
            process.exit(1);
        }
        if (args.isAndroid && !args.appiumCaps[appActivityProp]) {
            logError(`Please, provide ${appActivityProp} in ${args.appiumCapsLocation} file!`);
            process.exit(1);
        }
        const groupings = exports.getRegexResultsAsArray(/(\w+)/gi, args.appiumCaps[appPackage]);
        args.appName = groupings[groupings.length - 1];
        console.log(`Setting application name as ${args.appName}`);
        if (!args.devMode && !args.ignoreDeviceController && args.cleanApp) {
            logInfo("Check and uninstall application from device.");
            yield args.deviceManager.uninstallApp(args);
        }
        else {
            args.appiumCaps.app = "";
        }
    }
    if (!args.ignoreDeviceController
        && (args.attachToDebug || args.sessionId)
        && !args.appiumCaps[appPackage]
        && args.isIOS
        && args.appiumCaps.app) {
        args.appiumCaps[appPackage] = mobile_devices_controller_1.IOSController.getBundleId(undefined, args.appiumCaps.app);
    }
    if (args.appiumCaps[appPackage] && !args.appName) {
        const groupings = exports.getRegexResultsAsArray(/(\w+)/gi, args.appiumCaps[appPackage]);
        args.appName = groupings[groupings.length - 1];
    }
    return args;
});
exports.ensureReportsDirExists = (nsCapabilities) => {
    if (nsCapabilities
        && nsCapabilities.testReporter
        && nsCapabilities.testReporter.reportDir
        && !fs_1.existsSync(nsCapabilities.testReporter.reportDir)) {
        fs_1.mkdirSync(nsCapabilities.testReporter.reportDir);
    }
};
exports.checkImageLogType = (testReporter, logImageType) => {
    return testReporter
        && Object.getOwnPropertyNames(testReporter).length > 0
        && testReporter.logImageTypes
        && testReporter.logImageTypes.indexOf(logImageType) > -1;
};
exports.sessionIds = (port) => __awaiter(this, void 0, void 0, function* () {
    const sessions = JSON.parse(((yield getSessions(port)) || "{}") + '');
    const ids = [];
    sessions.value.forEach(value => {
        ids.push(value.id);
    });
    return ids;
});
function encodeImageToBase64(path) {
    const bitmap = fs_1.readFileSync(path);
    // convert binary data to base64 encoded string
    return new Buffer(bitmap).toString('base64');
}
exports.encodeImageToBase64 = encodeImageToBase64;
const convertObjToString = obj => {
    try {
        if (obj) {
            return " " + JSON.stringify(obj);
        }
    }
    catch (err) { }
    return "";
};
exports.shouldUserMobileDevicesController = (args) => {
    const useDsCS = process.env["USE_DEVICES_CONTROLLER_SERVER"] || false;
    const useMDsCS = process.env["USE_MOBILE_DEVICES_CONTROLLER_SERVER"] || false;
    return !args.isSauceLab && (new RegExp(`${useDsCS}`).test(`true`) || new RegExp(`${useMDsCS}`).test(`true`));
};
exports.stopServerCommand = (port) => {
    return `lsof -i tcp:${port} | grep -v grep | grep -v PID | awk '{print $2}' | xargs kill -9 || true`;
};
function logInfo(info, obj = undefined) {
    info += " " + convertObjToString(obj);
    console.log(`${ConsoleColor.FgCyan}%s${ConsoleColor.Reset}`, info);
}
exports.logInfo = logInfo;
function logWarn(info, obj = undefined) {
    info += " " + convertObjToString(obj);
    console.log(`${ConsoleColor.BgYellow}${ConsoleColor.FgBlack}%s${ConsoleColor.Reset}`, info);
}
exports.logWarn = logWarn;
function logError(info, obj = undefined) {
    info += " " + convertObjToString(obj);
    console.log(`${ConsoleColor.BgRed}%s${ConsoleColor.Reset}`, info);
}
exports.logError = logError;
function log(message, verbose) {
    if (verbose) {
        console.log(message);
    }
}
exports.log = log;
exports.logColorized = (bgColor, frontColor, info) => {
    console.log(`${ConsoleColor.BgYellow}${ConsoleColor.FgBlack}%s${ConsoleColor.Reset}`, info);
};
function adbShellCommand(wd, command, args) {
    return __awaiter(this, void 0, void 0, function* () {
        yield wd.execute('mobile: shell', { "command": command, "args": args });
    });
}
exports.adbShellCommand = adbShellCommand;
var ConsoleColor;
(function (ConsoleColor) {
    ConsoleColor["Reset"] = "\u001B[0m";
    ConsoleColor["Bright"] = "\u001B[1m";
    ConsoleColor["Dim"] = "\u001B[2m";
    ConsoleColor["Underscore"] = "\u001B[4m";
    ConsoleColor["Blink"] = "\u001B[5m";
    ConsoleColor["Reverse"] = "\u001B[7m";
    ConsoleColor["Hidden"] = "\u001B[8m";
    ConsoleColor["FgBlack"] = "\u001B[30m";
    ConsoleColor["FgRed"] = "\u001B[31m";
    ConsoleColor["FgGreen"] = "\u001B[32m";
    ConsoleColor["FgYellow"] = "\u001B[33m";
    ConsoleColor["FgBlue"] = "\u001B[34m";
    ConsoleColor["FgMagenta"] = "\u001B[35m";
    ConsoleColor["FgCyan"] = "\u001B[36m";
    ConsoleColor["FgWhite"] = "\u001B[37m";
    ConsoleColor["BgBlack"] = "\u001B[40m";
    ConsoleColor["BgRed"] = "\u001B[41m";
    ConsoleColor["BgGreen"] = "\u001B[42m";
    ConsoleColor["BgYellow"] = "\u001B[43m";
    ConsoleColor["BgBlue"] = "\u001B[44m";
    ConsoleColor["BgMagenta"] = "\u001B[45m";
    ConsoleColor["BgCyan"] = "\u001B[46m";
    ConsoleColor["BgWhite"] = "\u001B[47m";
})(ConsoleColor || (ConsoleColor = {}));
//# sourceMappingURL=utils.js.map