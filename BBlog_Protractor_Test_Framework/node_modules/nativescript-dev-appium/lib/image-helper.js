"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BlinkDiff = require("blink-diff");
const PngJsImage = require("pngjs-image");
const image_options_1 = require("./image-options");
const log_image_type_1 = require("./enums/log-image-type");
const utils_1 = require("./utils");
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = require("util");
const utils_2 = require("mobile-devices-controller/lib/utils");
class ImageHelper {
    constructor(_args, _driver) {
        this._args = _args;
        this._driver = _driver;
        this._imagesResults = new Map();
        this._options = {};
        this._defaultToleranceType = image_options_1.ImageOptions.percent;
        this._defaultTolerance = 0;
        this._defaultOptions = {
            timeOutSeconds: 2,
            tolerance: 0,
            toleranceType: image_options_1.ImageOptions.pixel,
            waitBeforeCreatingInitialImageCapture: 5000,
            donNotAppendActualSuffixOnIntialImageCapture: false,
            keepOriginalImageSize: true,
            keepOriginalImageName: false,
            isDeviceSpecific: true,
            cropRectangle: {},
            imageName: undefined,
            overwriteActualImage: false,
        };
        /**
         * Defines when an image output should be created.
         * This can be for different images, similar or different images, or all comparisons.
         * (default: BlinkDiff.OUTPUT_ALL)
         */
        this.imageOutputLimit = image_options_1.ImageOptions.outputAll;
        /**
         * Max. distance colors in the 4 dimensional color-space without triggering a difference. (default: 20)
         */
        this.delta = 20;
        if (this._args.device.viewportRect) {
            ImageHelper.fullClone(this._args.device.viewportRect, this._defaultOptions.cropRectangle);
        }
        if (!this._defaultOptions.cropRectangle
            || !util_1.isNumber(this._defaultOptions.cropRectangle.y) || this._args.appiumCaps.offsetPixels > 0) {
            this._defaultOptions.cropRectangle = this._defaultOptions.cropRectangle || {};
            this._defaultOptions.cropRectangle.y = this._args.appiumCaps.offsetPixels || this._args.device.config.offsetPixels || 0;
            this._defaultOptions.cropRectangle.x = 0;
            if (this._args.device.deviceScreenSize && this._args.device.deviceScreenSize.width && this._args.device.deviceScreenSize.height) {
                this._defaultOptions.cropRectangle.height = this._args.device.deviceScreenSize.height - this._defaultOptions.cropRectangle.y;
                this._defaultOptions.cropRectangle.width = this._args.device.deviceScreenSize.width - this._defaultOptions.cropRectangle.x;
            }
        }
        ImageHelper.fullClone(this._defaultOptions, this._options);
        utils_2.logInfo(`Actual view port:`, this._options);
    }
    get options() {
        return this._options;
    }
    set options(options) {
        this._options = this.extendOptions(options);
    }
    get blockOutAreas() {
        return this._blockOutAreas;
    }
    set blockOutAreas(rectangles) {
        this._blockOutAreas = rectangles;
    }
    get defaultToleranceType() {
        return this._defaultToleranceType;
    }
    set defaultToleranceType(toleranceType) {
        this._defaultToleranceType = toleranceType;
    }
    get defaultTolerance() {
        return this._defaultTolerance;
    }
    set defaultTolerance(tolerance) {
        this._defaultTolerance = tolerance;
    }
    compareScreen(options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = this.extendOptions(options);
            options.imageName = this.increaseImageName(options.imageName || this.testName, options);
            const result = yield this.compare(options);
            this._imagesResults.set(options.imageName, result);
            return result;
        });
    }
    compareElement(element, options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = this.extendOptions(options);
            options.imageName = this.increaseImageName(options.imageName || this.testName, options);
            const cropRectangle = yield element.getActualRectangle();
            const result = yield this.compareRectangle(cropRectangle, options);
            return result;
        });
    }
    compareRectangle(cropRectangle, options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = this.extendOptions(options);
            options.imageName = this.increaseImageName(options.imageName || this.testName, options);
            options.cropRectangle = cropRectangle;
            const result = yield this.compare(options);
            this._imagesResults.set(options.imageName, result);
            return result;
        });
    }
    hasImageComparisonPassed() {
        let shouldFailTest = true;
        console.log();
        this._imagesResults.forEach((v, k, map) => {
            if (!this._imagesResults.get(k)) {
                shouldFailTest = false;
                this._driver.testReporterLog(`Image comparison for image ${k} has failed!`);
                utils_1.logError(`Image comparison for image ${k} has failed`);
            }
        });
        this.reset();
        return shouldFailTest;
    }
    /**
     * Reset image comparison results
     */
    reset() {
        this._imagesResults.clear();
        this.testName = undefined;
    }
    /**
     * Set comparison option to default
     */
    resetDefaultOptions() {
        ImageHelper.fullClone(this._defaultOptions, this._options);
    }
    getExpectedImagePathByDevice(imageName) {
        let pathExpectedImage = utils_1.resolvePath(this._args.storageByDeviceName, imageName);
        return pathExpectedImage;
    }
    getExpectedImagePathByPlatform(imageName) {
        let pathExpectedImage = utils_1.resolvePath(this._args.storageByPlatform, imageName);
        return pathExpectedImage;
    }
    compare(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let imageName = utils_1.addExt(options.imageName, ImageHelper.pngFileExt);
            const storageLocal = options.isDeviceSpecific ? this._args.storageByDeviceName : this._args.storageByPlatform;
            const pathExpectedImage = options.isDeviceSpecific ? this.getExpectedImagePathByDevice(imageName) : this.getExpectedImagePathByPlatform(imageName);
            if (!fs_1.existsSync(this._args.reportsPath)) {
                fs_1.mkdirSync(this._args.reportsPath);
            }
            const captureFirstImage = () => __awaiter(this, void 0, void 0, function* () {
                const pathActualImage = utils_1.resolvePath(storageLocal, (this.options.donNotAppendActualSuffixOnIntialImageCapture || this.options.overwriteActualImage) ? imageName : imageName.replace(".", "_actual."));
                if (this.options.waitBeforeCreatingInitialImageCapture > 0) {
                    yield this._driver.wait(this.options.waitBeforeCreatingInitialImageCapture);
                }
                yield this._driver.saveScreenshot(pathActualImage);
                if (!options.keepOriginalImageSize) {
                    yield this.clipRectangleImage(options.cropRectangle, pathActualImage);
                }
                const pathActualImageToReportsFolder = utils_1.resolvePath(this._args.reportsPath, path_1.basename(pathActualImage));
                utils_1.copy(pathActualImage, pathActualImageToReportsFolder, false);
                if (this.options.donNotAppendActualSuffixOnIntialImageCapture || this.options.overwriteActualImage) {
                    utils_1.logWarn(`New image ${path_1.basename(pathActualImage)} is saved to storage ${storageLocal}.`, pathExpectedImage);
                }
                else if (this.options.donNotAppendActualSuffixOnIntialImageCapture === false && this.options.overwriteActualImage === false) {
                    utils_1.logWarn("Remove the 'actual' suffix to continue using the image as expected one ", pathExpectedImage);
                }
                this._args.testReporterLog(path_1.basename(pathActualImage).replace(/\.\w{3,3}$/ig, ""));
                this._args.testReporterLog(path_1.join(this._args.reportsPath, path_1.basename(pathActualImage)));
                return false;
            });
            // First time capture
            if (!fs_1.existsSync(pathExpectedImage)) {
                yield captureFirstImage();
                return false;
            }
            // Compare
            let pathActualImage = yield this._driver.saveScreenshot(utils_1.resolvePath(this._args.reportsPath, imageName.replace(".", "_actual.")));
            if (!options.keepOriginalImageSize) {
                yield this.clipRectangleImage(options.cropRectangle, pathActualImage);
            }
            const pathDiffImage = pathActualImage.replace("actual", "diff");
            console.log(`\n Comparing ${pathExpectedImage}`);
            // await this.prepareImageToCompare(pathActualImage, options.cropRectangle);
            let result = yield this.compareImages(options, pathActualImage, pathExpectedImage, pathDiffImage);
            // Iterate
            if (!result) {
                const eventStartTime = Date.now().valueOf();
                let counter = 1;
                options.timeOutSeconds *= 1000;
                let pathActualImageCounter = utils_1.resolvePath(this._args.reportsPath, imageName.replace(".", "_actual."));
                const shouldLogEveryImage = utils_1.checkImageLogType(this._args.testReporter, log_image_type_1.LogImageType.everyImage);
                while ((Date.now().valueOf() - eventStartTime) <= options.timeOutSeconds && !result) {
                    if (shouldLogEveryImage) {
                        pathActualImageCounter = utils_1.resolvePath(this._args.reportsPath, imageName.replace(".", "_actual_" + counter + "."));
                    }
                    pathActualImage = yield this._driver.saveScreenshot(pathActualImageCounter);
                    if (!options.keepOriginalImageSize) {
                        yield this.clipRectangleImage(options.cropRectangle, pathActualImage);
                    }
                    // await this.prepareImageToCompare(pathActualImage, this.imageCropRect);
                    result = yield this.compareImages(options, pathActualImage, pathExpectedImage, pathDiffImage);
                    if (!result && utils_1.checkImageLogType(this._args.testReporter, log_image_type_1.LogImageType.everyImage)) {
                        this._args.testReporterLog(`Actual image: ${path_1.basename(pathActualImage).replace(/\.\w{3,3}$/ig, "")}`);
                        this._args.testReporterLog(path_1.join(this._args.reportsPath, path_1.basename(pathActualImage)));
                    }
                    counter++;
                }
                if (options.overwriteActualImage === true && !result) {
                    utils_1.logError(`Overwrite image ${pathExpectedImage}, since overwriteActualImage option is set to true!`);
                    yield captureFirstImage();
                }
                if (!result && !utils_1.checkImageLogType(this._args.testReporter, log_image_type_1.LogImageType.everyImage)) {
                    this._args.testReporterLog(`${path_1.basename(pathDiffImage).replace(/\.\w{3,3}$/ig, "")}`);
                    this._args.testReporterLog(path_1.join(this._args.reportsPath, path_1.basename(pathDiffImage)));
                    this._args.testReporterLog(`Actual image: ${path_1.basename(pathActualImage).replace(/\.\w{3,3}$/ig, "")}`);
                    this._args.testReporterLog(path_1.join(this._args.reportsPath, path_1.basename(pathActualImage)));
                }
            }
            else {
                if (fs_1.existsSync(pathDiffImage)) {
                    fs_1.unlinkSync(pathDiffImage);
                }
                if (fs_1.existsSync(pathActualImage)) {
                    fs_1.unlinkSync(pathActualImage);
                }
            }
            return result;
        });
    }
    compareImages(options, actual, expected, output) {
        const clipRect = {
            x: options.cropRectangle.x,
            y: options.cropRectangle.y,
            width: options.cropRectangle.width,
            height: options.cropRectangle.height
        };
        if (!options.keepOriginalImageSize) {
            clipRect.x = 0;
            clipRect.y = 0;
            clipRect.width = undefined;
            clipRect.height = undefined;
        }
        const diff = new BlinkDiff({
            imageAPath: actual,
            imageBPath: expected,
            imageOutputPath: output,
            imageOutputLimit: this.imageOutputLimit,
            thresholdType: options.toleranceType,
            threshold: options.tolerance,
            delta: this.delta,
            cropImageA: clipRect,
            cropImageB: clipRect,
            blockOut: this._blockOutAreas,
            verbose: this._args.verbose,
        });
        if (options.toleranceType == image_options_1.ImageOptions.percent) {
            if (options.tolerance >= 1) {
                utils_1.logError("Tolerance range is from 0 to 1 -> percentage thresholds: 1 = 100%, 0.2 = 20%");
            }
            console.log(`Using ${options.tolerance * 100}% tolerance`);
        }
        else {
            console.log(`Using ${options.tolerance}px tolerance`);
        }
        const result = this.runDiff(diff, output);
        this._blockOutAreas = undefined;
        return result;
    }
    clipRectangleImage(rect, path) {
        return __awaiter(this, void 0, void 0, function* () {
            let imageToClip;
            imageToClip = yield this.readImage(path);
            let shouldExit = false;
            if (!util_1.isNumber(rect["x"])
                || !util_1.isNumber(rect["y"])
                || !util_1.isNumber(rect["width"])
                || !util_1.isNumber(rect["height"])) {
                shouldExit = true;
            }
            if (shouldExit) {
                utils_1.logError(`Could not crop the image. Not enough data {x: ${rect["x"]}, y: ${rect["y"]}, width: ${rect["width"]}, height: ${rect["height"]}}`);
            }
            if (!shouldExit) {
                imageToClip.clip(rect.x, rect.y, rect.width, rect.height);
            }
            else {
                utils_1.logWarn("Image will not be cropped!");
                return true;
            }
            return new Promise((resolve, reject) => {
                try {
                    imageToClip.writeImage(path, (err) => {
                        if (err) {
                            return reject(err);
                        }
                        return resolve();
                    });
                }
                catch (error) {
                    utils_1.logError(error);
                }
            });
        });
    }
    readImage(path) {
        return new Promise((resolve, reject) => {
            PngJsImage.readImage(path, (err, image) => {
                if (err) {
                    return reject(err);
                }
                return resolve(image);
            });
        });
    }
    runDiff(diffOptions, diffImage) {
        var that = this;
        return new Promise((resolve, reject) => {
            diffOptions.run(function (error, result) {
                if (error) {
                    throw error;
                }
                else {
                    const resultCode = diffOptions.hasPassed(result.code);
                    if (resultCode) {
                        console.log('Screen compare passed! Found ' + result.differences + ' differences.');
                        return resolve(true);
                    }
                    else {
                        const message = `Screen compare failed! Found ${result.differences} differences.\n`;
                        console.log(message);
                        if (Object.getOwnPropertyNames(that._args.testReporter).length > 0) {
                            that._args.testReporterLog(message);
                            if (that._args.testReporter.logImageTypes
                                && that._args.testReporter.logImageTypes.indexOf(log_image_type_1.LogImageType.everyImage) > -1) {
                                that._args.testReporterLog(`${path_1.basename(diffImage)} - ${message}`);
                                that._args.testReporterLog(diffImage);
                            }
                        }
                        return resolve(false);
                    }
                }
            });
        });
    }
    increaseImageName(imageName, options) {
        if (options.keepOriginalImageName) {
            return imageName;
        }
        if (!imageName) {
            utils_1.logError(`Missing image name!`);
            utils_1.logError(`Consider to set
            drive.imageHelper.testName
            driver.imageHelper.options.imageName`);
            throw new Error(`Missing image name!`);
        }
        if (this._imagesResults.size > 0) {
            const images = new Array();
            this._imagesResults.forEach((v, k, map) => {
                if (k.includes(imageName)) {
                    images.push(k);
                }
            });
            images.sort((a, b) => {
                const aNumber = +/\d+$/.exec(a);
                const bNumber = +/\d+$/.exec(b);
                return bNumber - aNumber;
            });
            if (images.length > 0) {
                const lastImage = images[0];
                const number = /\d+$/.test(lastImage) ? +`${/\d+$/.exec(lastImage)}` + 1 : `2`;
                imageName = `${imageName}_${number}`;
            }
        }
        return imageName;
    }
    extendOptions(options) {
        options = options || {};
        Object.getOwnPropertyNames(this.options).forEach(prop => {
            if (options[prop] === undefined || options[prop] === null) {
                if (util_1.isObject(this.options[prop])) {
                    options[prop] = {};
                    ImageHelper.fullClone(this.options[prop], options[prop]);
                }
                else {
                    options[prop] = this.options[prop];
                }
            }
        });
        return options;
    }
    static fullClone(src, target) {
        Object.getOwnPropertyNames(src)
            .forEach(prop => {
            if (util_1.isObject(src[prop])) {
                target[prop] = {};
                ImageHelper.fullClone(src[prop], target[prop]);
            }
            else {
                if (target[prop] === undefined || target[prop] === null) {
                    target[prop] = src[prop];
                }
            }
        });
    }
}
ImageHelper.pngFileExt = '.png';
exports.ImageHelper = ImageHelper;
//# sourceMappingURL=image-helper.js.map