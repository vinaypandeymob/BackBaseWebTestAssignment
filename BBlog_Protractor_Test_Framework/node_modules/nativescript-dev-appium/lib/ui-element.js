"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const point_1 = require("./point");
const automation_name_1 = require("./automation-name");
const utils_1 = require("./utils");
const mobile_devices_controller_1 = require("mobile-devices-controller");
class UIElement {
    constructor(_element, _driver, _wd, _webio, _args, _searchMethod, _searchParams, _index) {
        this._element = _element;
        this._driver = _driver;
        this._wd = _wd;
        this._webio = _webio;
        this._args = _args;
        this._searchMethod = _searchMethod;
        this._searchParams = _searchParams;
        this._index = _index;
    }
    /**
     * Click on element
     */
    click() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (yield this.element()).click();
        });
    }
    tapCenter() {
        return __awaiter(this, void 0, void 0, function* () {
            let action = new this._wd.TouchAction(this._driver);
            const rect = yield this.getActualRectangle();
            this._args.testReporterLog(`Tap on center element ${{ x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 }}`);
            action
                .tap({ x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 });
            yield action.perform();
            yield this._driver.sleep(150);
        });
    }
    tapAtTheEnd() {
        return __awaiter(this, void 0, void 0, function* () {
            let action = new this._wd.TouchAction(this._driver);
            const rect = yield this.getActualRectangle();
            action
                .tap({ x: (rect.x + rect.width) - 1, y: rect.y + rect.height / 2 });
            yield action.perform();
            yield this._driver.sleep(150);
        });
    }
    /**
     * @deprecated
     * Tap on element
     * This method is not working very good with UiAutomator2
     * It is better to use click instead.
     */
    tap() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._args.automationName == automation_name_1.AutomationName.UiAutomator2) {
                return yield this.tapCenter();
            }
            else {
                return yield (yield this.element()).tap();
            }
        });
    }
    /**
     * Double tap on element
     */
    doubleTap() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._driver.execute('mobile: doubleTap', { element: (yield this.element()).value.ELEMENT });
        });
    }
    /**
     * Get location of element
     */
    location() {
        return __awaiter(this, void 0, void 0, function* () {
            const location = yield (yield this.element()).getLocation();
            const point = new point_1.Point(location.x, location.y);
            return point;
        });
    }
    /**
     * Get size of element
     */
    size() {
        return __awaiter(this, void 0, void 0, function* () {
            const size = yield (yield this.element()).getSize();
            const point = new point_1.Point(size.height, size.width);
            return point;
        });
    }
    /**
     * Get text of element
     */
    text() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (yield this.element()).text();
        });
    }
    /**
    * Returns if an element is selected
    */
    isSelected() {
        return __awaiter(this, void 0, void 0, function* () {
            const el = (yield this.element());
            if (!el)
                return false;
            if (this._args.isAndroid) {
                try {
                    yield el.getAttribute("selected");
                }
                catch (error) {
                    console.error("Check if this is the correct element!");
                }
            }
            try {
                return yield el.isSelected();
            }
            catch (ex) {
                console.warn("'selected' attr is not reachable on this element!");
            }
            console.warn("Trying use 'value' attr!");
            try {
                const attrValue = yield el.getAttribute("value");
                return attrValue === "1" || attrValue === "true" || attrValue === true;
            }
            catch (error) {
                return false;
            }
        });
    }
    /**
     * Selected an element
     */
    select(retries = 3) {
        return __awaiter(this, void 0, void 0, function* () {
            (yield (yield this.element())).click();
            let el = (yield this.element());
            if (!el)
                return el;
            let isSelected = yield this.isSelected();
            while (retries >= 0 && !isSelected) {
                (yield (yield this.element())).click();
                isSelected = yield this.isSelected();
                retries--;
                yield this._driver.sleep(200);
            }
            return el;
        });
    }
    /**
     * Returns if an element is checked
     */
    isChecked() {
        return __awaiter(this, void 0, void 0, function* () {
            const el = (yield this.element());
            if (!el)
                return false;
            if (this._args.isAndroid) {
                try {
                    const isChecked = yield el.getAttribute("checked");
                    return isChecked === "true" || isChecked === true;
                }
                catch (error) {
                    console.error("Check if this is the correct element!");
                }
            }
            console.warn("Trying use 'value' attr!");
            try {
                const attrValue = yield el.getAttribute("value");
                return attrValue === "1" || attrValue === "true" || attrValue === true;
            }
            catch (error) {
                return false;
            }
        });
    }
    /**
     * Get web driver element
     */
    element() {
        return __awaiter(this, void 0, void 0, function* () {
            this._element = yield this.refetch();
            return this._element;
        });
    }
    /**
     * Shows if element is displayed. Returns true or false. If the element doesn't exist it will return false
     */
    isDisplayed() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const el = yield this._element;
                let isDisplayed = true;
                if (!el || el === null) {
                    return false;
                }
                const isDisplayedWebDriver = yield el.isDisplayed();
                if (!isDisplayedWebDriver) {
                    return false;
                }
                const displaySize = yield this._driver.getWindowSize();
                const elemCoordinates = yield el.getLocation();
                isDisplayed = isDisplayedWebDriver && elemCoordinates.x >= 0 && elemCoordinates.x < displaySize.width
                    && elemCoordinates.y >= 0 && elemCoordinates.y < displaySize.height;
                return isDisplayed;
            }
            catch (error) {
                return false;
            }
        });
    }
    /**
     * Returns true or false
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.element() === null ? false : true;
        });
    }
    /**
     * Waits until the element exists not.
     * @param wait
     */
    waitForExistNot(wait = 3000) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._webio.waitForExist(this._searchParams, wait, true);
        });
    }
    /**
     * Wait until the elements appear
     * @param wait
     */
    waitForExist(wait = 3000) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._webio.waitForExist(this._searchParams, wait, false);
        });
    }
    /**
     * Get attribute of element
     * @param attr
     */
    getAttribute(attr) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (yield this.element()).getAttribute(attr);
        });
    }
    /**
     * Get rectangle of element
     */
    getRectangle() {
        return __awaiter(this, void 0, void 0, function* () {
            const location = yield this.location();
            const size = yield this.size();
            const rect = { x: location.x, y: location.y, width: size.y, height: size.x };
            return rect;
        });
    }
    /**
     * Get rectangle of element in actual dimensions
     */
    getActualRectangle() {
        return __awaiter(this, void 0, void 0, function* () {
            const actRect = yield this.getRectangle();
            const density = this._args.device.deviceScreenDensity;
            if (this._args.isIOS) {
                if (density) {
                    actRect.x *= density;
                    actRect.y *= density;
                    actRect.width *= density;
                    actRect.height *= density;
                }
                else {
                    utils_1.logError("Device's density is undefined!");
                }
            }
            return actRect;
        });
    }
    /**
     * Scroll with offset from element with minimum inertia
     * @param direction
     * @param yOffset
     * @param xOffset
     */
    scroll(direction, yOffset = 0, xOffset = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            //await this._driver.execute("mobile: scroll", [{direction: 'up'}])
            //await this._driver.execute('mobile: scroll', { direction: direction === 0 ? "down" : "up", element: this._element.ELEMENT });
            const location = yield this.location();
            const size = yield this.size();
            const x = location.x === 0 ? 10 : location.x;
            let y = (location.y + 15);
            if (yOffset === 0) {
                yOffset = location.y + size.y - 15;
            }
            if (direction === 0 /* down */) {
                y = (location.y + size.y) - 15;
                if (!this._webio.isIOS) {
                    if (yOffset === 0) {
                        yOffset = location.y + size.y - 15;
                    }
                }
            }
            if (direction === 1 /* up */) {
                if (yOffset === 0) {
                    yOffset = size.y - 15;
                }
            }
            const endPoint = utils_1.calculateOffset(direction, y, yOffset, x, xOffset, this._webio.isIOS, false);
            if (direction === 0 /* down */) {
                //endPoint.point.y += location.y;
            }
            let action = new this._wd.TouchAction(this._driver);
            action
                .press({ x: x, y: y })
                .wait(endPoint.duration)
                .moveTo({ x: endPoint.point.x, y: endPoint.point.y })
                .release();
            yield action.perform();
            yield this._driver.sleep(150);
        });
    }
    /**
     * Scroll with offset from element with minimum inertia
     * @param direction
     * @param yOffset
     * @param xOffset
     */
    scrollTo(direction, elementToSearch, yOffset = 0, xOffset = 0, retries = 10) {
        return __awaiter(this, void 0, void 0, function* () {
            //await this._driver.execute("mobile: scroll", [{direction: 'up'}])
            //await this._driver.execute('mobile: scroll', { direction: direction === 0 ? "down" : "up", element: this._element.ELEMENT });
            let el = null;
            while (el === null && retries >= 0) {
                try {
                    el = yield elementToSearch();
                    if (!el || el === null || !(yield el.isDisplayed())) {
                        el = null;
                        yield this.scroll(direction, yOffset, xOffset);
                    }
                }
                catch (error) {
                    yield this.scroll(direction, yOffset, xOffset);
                }
                retries--;
            }
            return el;
        });
    }
    /**
 * Drag element with specific offset
 * @param direction
 * @param yOffset
 * @param xOffset - default value 0
 */
    drag(direction, yOffset, xOffset = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const location = yield this.location();
            const x = location.x === 0 ? 10 : location.x;
            const y = location.y === 0 ? 10 : location.y;
            const endPoint = utils_1.calculateOffset(direction, y, yOffset, x, xOffset, this._webio.isIOS, false);
            if (this._args.isAndroid) {
                let action = new this._wd.TouchAction(this._driver);
                action
                    .longPress({ x: x, y: y })
                    .wait(endPoint.duration)
                    .moveTo({ x: yOffset, y: yOffset })
                    .release();
                yield action.perform();
            }
            else {
                yield this._wd.execute(`mobile: dragFromToForDuration`, {
                    duration: endPoint.duration,
                    fromX: x,
                    fromY: y,
                    toX: xOffset,
                    toY: yOffset
                });
            }
            yield this._driver.sleep(150);
        });
    }
    /**
     * Click and hold over an element
     * @param time in milliseconds to increase the default press period.
     */
    hold(time) {
        return __awaiter(this, void 0, void 0, function* () {
            let action = new this._wd.TouchAction(this._driver);
            let durationTime = time ? time + 1000 : 1000;
            action
                .longPress({ el: yield this.element(), duration: durationTime })
                .release();
            yield action.perform();
            yield this._driver.sleep(150);
        });
    }
    /**
     * Send keys to field or other UI component
     * @param text The string to input
     * @param shouldClearText Clears existing input before send new one - default value is 'true'
     * @param useAdb default value is false. Usable for Android ONLY !
     * Must be combined with '--relaxed-security' appium flag. When not running in sauceLabs '--ignoreDeviceController' should be added too.
     * @param adbDeleteCharsCount default value is 10. Usable for Android ONLY when 'useAdb' and 'shouldClearText' are True!
     */
    sendKeys(text, shouldClearText = true, useAdb = false, adbDeleteCharsCount = 10) {
        return __awaiter(this, void 0, void 0, function* () {
            if (useAdb && this._args.isAndroid) {
                if (shouldClearText) {
                    yield this.adbDeleteText(adbDeleteCharsCount);
                }
                text = text.replace(" ", "%s");
                yield this.click();
                yield utils_1.adbShellCommand(this._driver, "input", ["text", text]);
            }
            else {
                if (shouldClearText) {
                    yield this.clearText();
                }
                yield this._element.sendKeys(text);
            }
        });
    }
    /**
    * Type text to field or other UI component
    * @param text
    * @param shouldClearText, default value is true
    */
    type(text, shouldClearText = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (shouldClearText) {
                yield this.clearText();
            }
            yield this._element.type(text);
        });
    }
    /**
    * Send key code to device
    * @param key code
    */
    pressKeycode(keyCode) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._driver.pressKeyCode(keyCode);
        });
    }
    /**
    * Clears text from ui element
    */
    clearText() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.click();
            yield this._element.clear();
        });
    }
    /**
    * Clears text from ui element with ADB. Android ONLY !
    * Must be combined with '--relaxed-security' appium flag. When not running in sauceLabs '--ignoreDeviceController' should be added too.
    * @param charactersCount Characters count to delete. (Optional - default value 10)
    */
    adbDeleteText(charactersCount = 10) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.click();
            for (let index = 0; index < charactersCount; index++) {
                // Keyevent 67 Delete (backspace)
                yield utils_1.adbShellCommand(this._driver, "input", ["keyevent", mobile_devices_controller_1.AndroidKeyEvent.KEYCODE_DEL]);
            }
        });
    }
    log() {
        return __awaiter(this, void 0, void 0, function* () {
            const el = yield this.element();
            console.dir(el);
            this._args.testReporterLog(el);
        });
    }
    refetch() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this._index != null) {
                    return (yield this._driver[this._searchMethod](this._searchParams, UIElement.DEFAULT_REFETCH_TIME))[this._index];
                }
                else {
                    return yield this._driver[this._searchMethod](this._searchParams, UIElement.DEFAULT_REFETCH_TIME);
                }
            }
            catch (error) {
                console.log("Refetch error: " + error);
                return null;
            }
        });
    }
    /**
     * Easy to use in order to chain and search for nested elements
     */
    driver() {
        return this._element.browser;
    }
    /**
    * Swipe element left/right
    * @param direction
    */
    swipe(direction) {
        return __awaiter(this, void 0, void 0, function* () {
            const rectangle = yield this.getRectangle();
            const centerX = rectangle.x + rectangle.width / 2;
            const centerY = rectangle.y + rectangle.height / 2;
            let swipeX;
            if (direction == 3 /* right */) {
                const windowSize = yield this._driver.getWindowSize();
                swipeX = windowSize.width - 10;
            }
            else if (direction == 2 /* left */) {
                swipeX = 10;
            }
            else {
                console.log("Provided direction must be left or right !");
            }
            if (this._args.isAndroid) {
                const action = new this._wd.TouchAction(this._driver);
                action.press({ x: centerX, y: centerY })
                    .wait(200)
                    .moveTo({ x: swipeX, y: centerY })
                    .release();
                yield action.perform();
            }
            else {
                yield this._driver.execute('mobile: dragFromToForDuration', {
                    duration: 2.0,
                    fromX: centerX,
                    fromY: centerY,
                    toX: swipeX,
                    toY: centerY
                });
            }
        });
    }
}
UIElement.DEFAULT_REFETCH_TIME = 1000;
exports.UIElement = UIElement;
//# sourceMappingURL=ui-element.js.map