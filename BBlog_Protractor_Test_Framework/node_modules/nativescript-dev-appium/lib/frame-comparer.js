"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const frComparer = require("frame-comparer");
const utils_1 = require("./utils");
function loadFrameComparer(nsCapabilities) {
    try {
        const storage = utils_1.getStorageByDeviceName(nsCapabilities);
        const logPath = utils_1.getReportPath(nsCapabilities);
        return new FrameComparer(nsCapabilities, storage, logPath);
    }
    catch (error) {
        console.error("In order to use frame comparer, please read carefully https://github.com/SvetoslavTsenov/frame-comparer/blob/master/README.md for dependencies that are required!");
    }
}
exports.loadFrameComparer = loadFrameComparer;
class FrameComparer {
    constructor(_nsCapabilities, _storage, _logPath) {
        this._nsCapabilities = _nsCapabilities;
        this._storage = _storage;
        this._logPath = _logPath;
        this._framesGeneralName = "frame";
        this._cropImageRect = this._nsCapabilities.appiumCaps.viewportRect || this._nsCapabilities.device.viewportRect;
    }
    processVideo(videoFullName, framesGeneralName, videoTempStorage = "tempFramesFolder") {
        return __awaiter(this, void 0, void 0, function* () {
            this._framesGeneralName = framesGeneralName || this._framesGeneralName;
            this._framesGeneralName = this._framesGeneralName.replace(/\s/gi, "");
            return yield frComparer.FrameComparer.processVideo(videoFullName, videoTempStorage, this._framesGeneralName);
        });
    }
    compareFrameRanges(frames, imageFrameCount, startRange, endRange, logImageComparisonResults = false, tolerancePixels = 0.1, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield frComparer.FrameComparer.compareImageFromVideo(frames, utils_1.resolvePath(this._storage, `${this._framesGeneralName}${imageFrameCount}.png`), this._logPath, startRange, endRange, tolerancePixels, true, logImageComparisonResults, this._cropImageRect, verbose);
            return result;
        });
    }
    compareFrames(frames, imageFrameCount, toleranceRange = 3, tolerancePixels = 0.1, logImageComparisonResults = false, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = imageFrameCount - toleranceRange > 0 ? imageFrameCount - toleranceRange : 0;
            const end = imageFrameCount + toleranceRange;
            const result = yield this.compareFrameRanges(frames, imageFrameCount, start, end, logImageComparisonResults, tolerancePixels);
            return result;
        });
    }
}
exports.FrameComparer = FrameComparer;
//# sourceMappingURL=frame-comparer.js.map