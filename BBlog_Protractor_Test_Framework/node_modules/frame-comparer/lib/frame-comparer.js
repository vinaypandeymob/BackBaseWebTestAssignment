"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ffmpeg = require("fluent-ffmpeg");
const blinkDiff = require("blink-diff");
const path_1 = require("path");
const fs_1 = require("fs");
class FrameComparer {
    static compareImageFromVideo(frames, expectedImageFullName, logStorage, startRange, endRange, tollerance = 0.2, saveActualImageAsExpected = true, shouldLogImageResults = false, cropImageRect = undefined, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!saveActualImageAsExpected && !fs_1.existsSync(expectedImageFullName)) {
                throw new Error(`${expectedImageFullName} is not available!!!`);
            }
            return new Promise((accept, reject) => __awaiter(this, void 0, void 0, function* () {
                endRange = endRange < frames.length ? endRange : frames.length;
                const filteredFrames = frames.filter(f => {
                    const number = FrameComparer.convertFrameNameToNumber(f);
                    return number >= startRange && number <= endRange;
                });
                let isExcpectedImageAvailable = true;
                for (let index = 0; index < filteredFrames.length; index++) {
                    if (verbose) {
                        console.log(filteredFrames[index]);
                    }
                    isExcpectedImageAvailable = fs_1.existsSync(expectedImageFullName);
                    const extn = path_1.extname(filteredFrames[index]);
                    const getFrameIndex = (fileName, extn) => /\d+/.exec(new RegExp(`\\d+` + extn).exec(fileName)[0])[0];
                    const desiredFrame = getFrameIndex(expectedImageFullName, extn);
                    const currentFrame = getFrameIndex(filteredFrames[index], extn);
                    if (saveActualImageAsExpected && !isExcpectedImageAvailable && desiredFrame === currentFrame) {
                        fs_1.writeFileSync(expectedImageFullName, fs_1.readFileSync(filteredFrames[index]));
                        isExcpectedImageAvailable = true;
                    }
                    if (isExcpectedImageAvailable) {
                        const diffImage = (!shouldLogImageResults || !logStorage) ? undefined : path_1.resolve(logStorage, path_1.basename(filteredFrames[index].replace(extn, `_diff${extn}`)));
                        const result = (yield FrameComparer.compareImages(filteredFrames[index], expectedImageFullName, diffImage, tollerance, blinkDiff.THRESHOLD_PERCENT, cropImageRect, verbose)).result;
                        if (result) {
                            return accept(true);
                        }
                    }
                }
                return accept(false);
            }));
        });
    }
    static getEqualImages(frames, expectedImageFullName, startRange, endRange, tollerance = 0.00, cropImageRect = undefined, verbose = true) {
        if (!fs_1.existsSync(expectedImageFullName)) {
            throw new Error(`${expectedImageFullName} is not available!!!`);
        }
        return new Promise((accept, reject) => __awaiter(this, void 0, void 0, function* () {
            endRange = endRange < frames.length ? endRange : frames.length - 1;
            const filteredFrames = frames.filter(f => {
                const number = FrameComparer.convertFrameNameToNumber(f);
                if (number >= startRange && number <= endRange) {
                    return true;
                }
                return false;
            }).sort((a, b) => {
                const numberA = FrameComparer.convertFrameNameToNumber(a);
                const numberB = FrameComparer.convertFrameNameToNumber(b);
                return numberA > numberB ? 1 : -1;
            });
            const equalFrames = new Map();
            let previosResult = undefined;
            for (let index = 0; index < filteredFrames.length; index++) {
                if (verbose) {
                    console.log(filteredFrames[index]);
                }
                const ext = path_1.extname(filteredFrames[index]);
                const diffImageName = verbose ? filteredFrames[index].replace(ext, `_diff${ext}`) : undefined;
                const result = yield FrameComparer.compareImages(filteredFrames[index], expectedImageFullName, diffImageName, tollerance, blinkDiff.THRESHOLD_PIXEL, cropImageRect, verbose);
                // if(!result.result && result.differences - previosResult > 40000 ){
                //     index = filteredFrames.length;
                // }
                previosResult = result.differences;
                if (result.result) {
                    const number = FrameComparer.convertFrameNameToNumber(filteredFrames[index]);
                    equalFrames.set(number, filteredFrames[index]);
                }
            }
            return accept(equalFrames);
        }));
    }
    static processVideo(fullVideoName, frameStorageFullName = "tempFramesFolder", framesGeneralName = "frame") {
        FrameComparer.cleanDir(frameStorageFullName);
        if (!fs_1.existsSync(frameStorageFullName)) {
            fs_1.mkdirSync(frameStorageFullName);
        }
        let lastFrameEnqueued = 0;
        const frames = new Array();
        ;
        const imageName = path_1.resolve(frameStorageFullName, framesGeneralName);
        return new Promise((res, reject) => {
            ffmpeg(fullVideoName)
                .on('error', function (err) {
                console.log('An error occurred: ' + err.message);
                reject();
            })
                .on('end', function () {
                console.log('Processing finished !');
                fs_1.readdirSync(frameStorageFullName)
                    .forEach((file) => {
                    file = path_1.resolve(frameStorageFullName, file);
                    frames.push(file);
                });
                return res(frames);
            })
                .on('progress', function (progress) {
                lastFrameEnqueued = progress.frames - 1;
                for (let n = lastFrameEnqueued + 1; n < progress.frames; n++) {
                    console.log(n);
                }
            })
                .save(`${imageName}%d.png`);
        });
    }
    static getMetaData(videoFullName) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                ffmpeg.ffprobe(videoFullName, function (err, metadata) {
                    //console.dir(metadata); // all metadata
                    console.log("Meta data info: ", metadata);
                    if (err) {
                        console.error(err);
                    }
                    resolve(metadata);
                });
            });
        });
    }
    static compareImages(actual, expected, output, valueThreshold = 0.01, typeThreshold, cropImageRect, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const diff = new blinkDiff({
                imageAPath: actual,
                cropImageA: cropImageRect,
                imageBPath: expected,
                cropImageB: cropImageRect,
                imageOutputPath: output,
                imageOutputLimit: blinkDiff.OUTPUT_ALL,
                thresholdType: typeThreshold,
                threshold: valueThreshold,
                delta: 20,
            });
            return yield FrameComparer.runDiff(diff, verbose);
        });
    }
    static runDiff(diffOptions, verbose) {
        return new Promise((resolve, reject) => {
            diffOptions.run(function (error, result) {
                if (error) {
                    throw error;
                }
                else {
                    let message;
                    let resultCode = diffOptions.hasPassed(result.code);
                    if (resultCode) {
                        if (verbose) {
                            message = "Screen compare passed!";
                            console.log(message);
                            console.log('Found ' + result.differences + ' differences.');
                        }
                        return resolve({ differences: result.differences, result: true });
                    }
                    else {
                        if (verbose) {
                            message = "Screen compare failed!";
                            console.log(message);
                            console.log('Found ' + result.differences + ' differences.');
                        }
                        return resolve({ differences: result.differences, result: false });
                    }
                }
            });
        });
    }
    static cleanDir(dirFullName) {
        if (fs_1.existsSync(dirFullName)) {
            const pathToFile = dirFullName;
            fs_1.readdirSync(dirFullName)
                .forEach(file => {
                const f = path_1.resolve(pathToFile, file);
                if (FrameComparer.isDirectory(f)) {
                    FrameComparer.cleanDir(f);
                }
                fs_1.unlinkSync(f);
            });
            //
            fs_1.rmdirSync(dirFullName);
        }
    }
    static isDirectory(fullName) {
        try {
            if (fs_1.existsSync(fullName) && fs_1.statSync(fullName).isDirectory()) {
                return true;
            }
        }
        catch (e) {
            return false;
        }
        return false;
    }
}
FrameComparer.convertFrameNameToNumber = frame => {
    return parseInt(/\d+/gm.exec(/\d+.png/gm.exec(frame)[0])[0]);
};
exports.FrameComparer = FrameComparer;
//# sourceMappingURL=frame-comparer.js.map